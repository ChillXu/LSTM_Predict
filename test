### C++中有几种类型的new

new有三种典型的使用方法：`plain new`，`nothrow new`和`placement new`

##### 1. plain new

```c++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的。

##### 2. nothrow new

```c++
void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

**nothrow new**在空间分配失败的情况下是不抛出异常，而是返回NULL。

##### 3. placement new

```c++
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。**placement new**不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。

**注意：**

- palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组。
- placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。



### C++的异常处理的方法

常见的异常有：

- 数组下标越界
- 除法计算时除数为0
- 动态分配空间时空间不足
- ...

##### 1. try、throw和catch关键字

```c++
#include <iostream>
using namespace std;
int main()
{
    int m = 1, n = 0;
    try {
        cout << "before dividing." << endl;
        if (n == 0)
            throw - 1;  //抛出 int 型异常
        else if (m == 0)
            throw - 1.0;  //拋出 double 型异常
        else
            cout << m / n << endl;
        cout << "after dividing." << endl;
    }
    catch (double d) {
        cout << "catch (double)" << d << endl;
    }
    catch (...) {
        cout << "catch (...)" << endl;
    }
    cout << "finished" << endl;
    return 0;
}
//运行结果
//before dividing.
//catch (...)
//finished
```

程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。**catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。**当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。



##### 2. 函数的异常声明列表

有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表。

```c++
int fun() throw(int,double,A,B,C){...};
//函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常
```



##### 3. C++标准异常类 exception

C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。

+ `bad_typeid`：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常。
+ `bad_cast`：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常。
+ `bad_alloc`：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。
+ `out_of_range`：用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常。



### 形参 & 实参

1. 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效，函数调用结束返回主调函数后则不能再使用该形参变量。
2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
3. 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误。
4. 函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5. 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。



### 值传递、指针传递 & 引用传递的区别和效率

1. **值传递：**有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）
2. **指针传递：**同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
3. **引用传递：**同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）

效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。



### 静态变量什么时候初始化

1. 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。
2. 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。
   + 在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化。所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。
   + 在C++中，初始化时在执行相关代码时才会进行初始化。主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过`atexit()`来管理。在程序结束，`按照构造顺序反方向进行逐个析构`。**所以在C++中是可以使用变量对静态局部变量进行初始化的。**



### delete p、delete [] p、allocator都有什么作用？

1. 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；
2. new动态数组返回的并不是数组类型，而是一个元素类型的指针；
3. delete[]时，数组中的元素按逆序的顺序进行销毁；
4. new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。`allocator`将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。



### new和delete的实现原理， delete如何知道释放内存的大小？

1. 对于简单类型，`new`直接调用operator new分配内存；而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数。
2. 对于简单类型，`new[]`计算好大小后调用operator new；对于复杂数据结构，new[]先调用operator new[]分配内存，然后在指针p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小。



① new(new[])表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；

② 编译器运行相应的构造函数以构造这些对象，并为其传入初始值；

③ 对象被分配了空间并构造完成，返回一个指向该对象的指针。



3. 对于简单数据类型，`delete`默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；
4. 针对简单类型，delete[]和delete等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。
5. 需要在 new[] 一个对象数组时，需要保存数组的维度，**C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。**



### malloc申请的存储空间能用delete释放吗?

不能。

1. malloc/free的操作对象都是必须明确大小的，而且不能用在动态类上。
2. new和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。



### malloc与free的实现原理

malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个`记录空闲内存地址的链表`。当操作系统收到程序的申请时，就会`遍历该链表`，然后就`寻找第一个空间大于所申请空间的堆结点`，然后就`将该结点从空闲结点链表中删除`，并`将该结点的空间分配给程序`。



### 类成员初始化方式

1. `赋值初始化`：通过在函数体内进行赋值初始化。
2. `列表初始化`：在冒号后使用初始化列表进行初始化。

这两种方式的主要区别：

对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的。

列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么**分配了内存空间后在进入函数体之前给数据成员赋值**，就是说初始化这个数据成员此时函数体还未执行。



**成员初始化列表做了什么：**

① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；

② list中的项目**初始化顺序**是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的。



### 为什么用成员初始化列表会快一些？

赋值初始化是在构造函数当中做赋值的操作，而列表初始化是做纯粹的初始化操作。因为C++的赋值操作是会产生临时对象的，临时对象的出现会降低程序的效率。



### 有哪些情况必须用到成员列表初始化

必须使用成员初始化的四种情况：

① 当初始化一个引用成员时；

② 当初始化一个常量成员时；

③ 当调用一个基类的构造函数，而它拥有一组参数时；

④ 当调用一个成员类的构造函数，而它拥有一组参数时；



### 构造函数的执行顺序 

一个派生类构造函数的执行顺序如下：

① 虚基类的构造函数（多个虚基类则按照继承的顺序执行构造函数）。

② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。

③ 类类型的成员对象的构造函数（按照初始化顺序）

④ 派生类自己的构造函数。



### C++中的string & C语言中的 char *

+ string继承自basic_string，其实是对`char*`进行了封装，封装的string包含了`char*`数组，容量，长度等等属性。
+ string可以进行**动态扩展**，在每次扩展的时候另外申请一块原空间大小两倍的空间（$2^n$），然后将原字符串拷贝过去，并加上新增的内容。
