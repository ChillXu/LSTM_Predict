### 44. ※Linux 基础IO

[Linux 基础IO](https://blog.csdn.net/qq_54851255/article/details/124908170)

##### 1. open & close

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

三个参数：

```c
pathname: 要打开或创建的目标文件文件名
flags:    打开方式。传递多个标志位，下面的一个或者多个常量进行“或”运算，构成flags.
             O_RDONLY: 只读打开
             O_WRONLY: 只写打开
             O_RDWR  : 读写打开
          以上这三个常量，必须指定一个且只能指定一个
             O_CREAT : 若文件不存在，则创建它。同时需要使用mode选项，来指明新文件的访问权限
             O_APPEND: 追加写
mode: 	  设置默认权限信息 
```

+ 创建文件，系统层面就**必须指定权限**；
+ int有32个bit位，一个bit代表一个标志，就可以**传递多个标志位**且位运算效率较高。O_RDONLY、O_WRONLY、O_RDWR 都是**只有一个比特位是1**的数据，并且相互不重复，这样`|`在一起，就能传递多个标志位；



##### 2. write & read

```c
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t count);
参数：
    buf: 用户缓冲区
    count: 期望写的字节数
返回值：实际写入的字节数
```

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
参数：
    buf: 读到的内容放在用户层缓冲区中，也就是自己定义缓冲区
    count: 期望读多少个字节
返回值：实际读多少个字节
```



### 45. 文件描述符 fd

文件描述符fd，本质是内核中**进程和打开文件关联**的**数组下标**。

##### 1. file descriptor

+ 如果一个文件没有被打开，这个文件是在磁盘上。如果我创建一个空文件，该文件也是要占用磁盘空间的，因为文件的属性早就存在了(包括名称、时间、类型、大小、权限、用户名所属组等等)，属性也是数据，所谓“空文件”是指文件内容为空。即`磁盘文件 = 文件内容 + 文件属性`。事实上，我们之前所学的所有**文件操作都可以分为两类**：**对文件内容的操作 + 对文件属性的操作**(fseek、ftell、rewind、chmod、chgrp等等)。
+ 要操作文件，必须**打开文件**，本质上，就是`文件相关的属性信息从磁盘加载到内存`。操作系统中存在大量进程，进程可以打开多个文件，即进程 : 文件 = 1 : n ，系统中可能存在着更多的打开的文件，OS把打开的文件在内存中(系统中)管理起来。

```c
struct file
{
    // 文件相关的的属性信息
    // 链接属性，把它们组织起来
};
```

操作系统为了**让进程和文件之间产生关联**，进程在内核创建`struct files_struct `的结构，这个结构包含了一个**数组** `struct file* fd_array[] `，也就是一个**指针**数组，把表述文件的结构体地址填入到特定下标中。

![img](https://img-blog.csdnimg.cn/1e126e19c94c4e84b5bfd950695b44c3.png)

新打开一个文件本质是内核会为我们描述`struct file`结构，再把`struct file`地址填入到`fd_array[]`数组下标去，因为012已经被占用了，于是填到**3号**下标。

> 当我们的程序运行起来变成**进程**，默认情况下，OS会帮助我们打开三个标准输入输出，**012**其实分别对应的就是**标准输入、标准输出、标准错误**。



**write**和**read**这样的系统调用接口为什么一定要传入文件描述符**fd**？

执行系统调用接口是进程执行的，通过进程PCB，找到自己打开的文件列表，通过fd索引数组找到对应的文件，从而对文件进行操作。



**子进程是否与父进程共享文件描述符呢？**

是的。但是子进程也有自己的`files_struct`结构体，因为这个结构是属于进程的。子进程内核的数据结构`task_struct`，会以父进程的为模板初始化自身，因此它们的文件描述符表就是两份完全一样的内容，但是这些打开的文件不会新建，即父子指向同一份文件。



##### 2. 理解一切皆文件

![img](https://img-blog.csdnimg.cn/d9c59fa4b11b477591849e3984e41793.png)

+ Linux中做了软件的虚拟层**vfs（虚拟文件系统）**，会统一维护每一个打开文件的结构体`struct file`。

+ C++中的多态，我们可以编写一个父类（甚至是纯虚的，相当于定义一个接口类），子类继承父类，重写函数。我们让父类指针指向不同的子类对象，就会调用对应的方法。

  在C语言中，可以通过**函数指针**，做到调用同一个方法，指向不同对象时可以执行不同的方法，从而实现多态的性质。

+ 在每个`struct file`当中包含上一大坨的函数指针，这样，在struct file**上层**看来所有的文件都是调用**统一的**接口；在**底层**我们通过函数指针指向不同硬件的方法。



##### 3. 文件描述符的分配规则

每次给新文件分配的`fd`，是从`fd_array[]`中找一个**最小的、未被使用的**作为新的`fd`。



### 46. 重定向原理

```c
 stdin  标准输入，键盘    --包含--> 	0: 标准输入，键盘 
 stdout 标准输出，显示器  --包含-->  1: 标准输出，显示器
 stderr 标准错误，显示器  --包含-->  2: 标准错误，显示器
```

##### 1. 输出重定向

![img](https://img-blog.csdnimg.cn/ab375901c60243039f76f16464e66aa9.png)

![img](https://img-blog.csdnimg.cn/c12a02ed33d94f46914d9998a9f53c84.png)

`close(1)`断开了与显示器文件的联系，相当于置NULL。对于打开新文件的log.txt，由文件描述符分配规则，1又指向log.txt。

![img](https://img-blog.csdnimg.cn/923d472f5887457180f403b2cc73f392.png)



##### 2. 追加重定向

**追加重定向**与**输出重定向**唯一的差别就是在**打开方式**上，增加`O_APPEND`选项。

![img](https://img-blog.csdnimg.cn/7fe43ab5f5504bdb9f393c5758b855b1.png)



##### 3. 输入重定向

输入重定向就是把本来应该从键盘获取内容变成从文件中获取。

![img](https://img-blog.csdnimg.cn/da3755321bbb4b9a8ae6ed9e2e627869.png)



##### 4. dup2

以上都是通过关闭文件然后再打开文件来重定向，如两个文件描述符1、3都已经被打开，如何实现重定向呢？

在语言层调用时接口函数只认1，那么只需要把文件描述符表的3中的内容**拷贝**到1中 ，就实现了原本应向显示器文件写入，而现在向log.txt写入。

```c
#include <unistd.h>

int dup2(int oldfd, int newfd); //oldfd->newfd
```



### 47. inode

##### 1. 文件在磁盘上是如何被保存的？

 ① **分区**：大磁盘 → 小空间，化整为零

 ② **格式化**：给每个分区**写入文件系统**。

![img](https://img-blog.csdnimg.cn/f19639d7428b46f9a2b3a2c88e67ed0f.png)

每个**分区**最开始都可以有`Boot Block `，是与启动相关的，供启动时查找分区。我们再把剩下的空间继续拆解**分组**，Block group 0，Block group 1 …

![img](https://img-blog.csdnimg.cn/6231f736a49149c7b269e91de582102b.png)

```c
// 包含所有文件的属性
struct inode
{ 
    //数据
    int inode_num;
    int blocks[32]; //数组存储了相关联的blocks块编号[102, 103, ....]
};
```

`文件 = 文件内容 + 文件属性`

**Data blocks**：文件**内容**

**inode Table**：文件**属性**

**inode Bitmap**：位图，

- 比特位的**位置含义**：inode编号(第几位)。
- 比特位的**内容含义**：特定inode“是否”被使用(0/1)。

**Block Bitmap**

**Group Descriptor Table：**表示组相关的信息，包括块组描述符、描述块组属性信息、所占空间、起始终止位置。

**Super Block：**表示着`Block Group 0 中空间的使用情况`，包括文件系统类型信息。存放文件系统本身的结构信息。记录的信息主要有：**bolck 和 inode的总量**，**未使用的block和inode的数量**，**一个block和inode的大小**，**最近一次挂载的时间**，**最近一次写入数据的时间**，**最近一次检验磁盘的时间**等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了。



##### 2. 目录也是文件吗？

目录有自己的**inode**，存放目录的大小、权限、（链接数）、拥有者、所属组等等。

目录的数据块**block**，存放**文件名和inode的映射关系**。



##### 3. 系统层面都做了什么？

1. **创建文件**：遍历inode Bitmap位图中找0，申请一个未被使用的inode，填入属性信息。并把这个映射关系写到当前`目录的Data blocks`中。
2. **查看目录**：根据目录inode找到与其映射的文件名。
3. **向文件写入**：遍历block Bitmap找到若干未被使用的块儿，将该文件的inode与这些blocks建立映射关系，再向blocks中写入内容。
4. **查看文件内容**：cat hello.c → 查看当前目录的data Blocks数据块儿 → 找到映射关系：文件名对应的inode编号 → 在inode Table中找到inode → 找到对应的blocks[] → 打印文件内容。 （查看文件属性类似）



##### 4. 删除文件做了什么？

**不需要**改文件的属性`inode Table`和数据`data Blocks`，只需要把对应**inode编号位**在**Bitmap**中**由1置0**；再根据属性把使用的**数据块儿们**也在**Bitmap**中把它**由1置0**。所以拷贝一个文件需要一会儿，但是删除很**快**。



### 48. 文件时间 acm

 **Acess**：文件最近一次被**访问**的时间

**Change**：最近一次修改文件**属性**的时间

**Modify**：最近一次修改文件**内容**的时间



### 49. 软链接 & 硬链接

##### a. 软链接

+ 对于一些执行路径非常深的程序，我们可以通过软链接快速找到它，相当于windows下的**创建快捷方式**。

+ **软链接有自己独立inode**，即软链接是一个**独立文件**。有自己的inode属性集也有自己的数据块儿（保存的是它所指向文件的路径 + 文件名）。

💛 建立**软链接**

```c
ln -s log.txt log_soft
```

💛 删除链接

```c
unlink log_soft
```



##### b. 硬链接

+ **硬链接没有独立的inode**，根本就不是一个独立的文件，**本质是**在特定目录下，添加一个**文件名和inode编号的映射关系**。

+ **硬链接数**，即有几个文件指向这个inode，这个数字存在于inode属性中，建立硬链接就是对ref++，删除某文件即对ref–。直到ref == 0时，这个文件才被干掉，这就是**引用计数**。
+ 文件的硬链接数是1，**目录**默认的硬链接数是2，因为在任何目录下的这两个隐藏文件，`.`表示当前目录，`..`表示上一级目录，其中`.`和我们的目录dir**对应的inode是同一个**。（如果在dir中再创建一个目录subdir，dir的硬链接数会变为3，因为subdir中的`..`也是dir的硬链接）

💛 建立**硬链接**

```c
ln log.c log_hard
```



### 50. 零拷贝

**零拷贝（ zero-copy ）**就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。**避免让CPU做大量的数据拷贝任务**，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。

`mmap`、`sendfile`、`splice`



##### 1. 场景：

在写一个服务端程序时（Web Server或者文件服务器），文件下载是一个基本功能，这时候服务端的任务是：将服务端主机磁盘中的文件不做修改地从已连接的socket发出去。

基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到socket。但是由于Linux的I/O操作默认是`缓冲I/O`，实际上发生了多次的数据拷贝。

![img](https://upload-images.jianshu.io/upload_images/2884841-51b4a63a9e0db92d.png?imageMogr2/auto-orient/strip|imageView2/2/w/544/format/webp)

当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，`write`系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上。

共产生了四次数据拷贝，即使使用了DMA来处理了与硬件的通讯，CPU仍然需要处理两次数据拷贝，与此同时，在用户态与内核态也发生了多次上下文切换，无疑也加重了CPU负担。

> DMA（Direct Memory Access，直接存储器访问），它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载



##### 2. 使用mmap

调用`mmap()`来代替`read`调用：

```c
buf = mmap(diskfd, len);
write(sockfd, buf, len);
```

应用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着`操作系统会把这段内核缓冲区与应用程序共享`，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write()，操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。

![img](https://upload-images.jianshu.io/upload_images/2884841-a9eecb409238e6f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)





##### 3. 使用sendfile

##### 4. 使用splice

https://www.jianshu.com/p/580a14db9d77?u_atoken=3c6b64a0-d788-466e-bc74-0ee37e15d7b7&u_asession=01a75S8SZu2XeJ8GJ6u637UqB91fXgwouajzklyK1F3TZKJQ7pP19LNn5KoozSXq89X0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_96QeqheJ8pTQmCzpFjFMH3TYvls7v_Epik-OyKXq1TWBkFo3NEHBv0PZUm6pbxQU&u_asig=05rxG5icSKLUFI70pJ_684h_Mtrgt5e3T_y5ftgN-tg4YiUkKTTrYs_ZL8n2rh_UyCqFmn0zVAk0SLL9SekORh0N4nFZ0zLVD5mc75AvZyXZ-Y0l2f5tmLdnqt6U7lb5cXj1V26lJzFTLpaf32hef0-e77jcsHRiFfmfMmACXaR_z9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzQgnvdAwrD4QYelL4nI5phs30e-kASnqi9E2KOwdvep5yZo170oZzfjmGNwwqqFezu3h9VXwMyh6PgyDIVSG1W9Abk18lRQuOAMqGMkU9LCLvcob-3mcfVCNS-ach8kgLkeHm_131QjwbEEMKWOW_spq5_A0mA_lyuKTczaeSMvjmWspDxyAEEo4kbsryBKb9Q&u_aref=Fcp03hjLrnT%2FkOPLkA6IXAYPKcc%3D



### 51. ※设备管理

### 52. 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg)



### 53. 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，**寻道时间最长**，因此**磁盘调度的主要目标**是使磁盘的平均寻道时间最短。



##### a. 先来先服务

> FCFS，First Come First Served

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。



##### b. 最短寻道时间优先

> SSTF，Shortest Seek Time First

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png)



##### c. 电梯算法

> SCAN

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/271ce08f-c124-475f-b490-be44fedc6d2e.png)





### 54. 用户空间和内核空间通信的几种方式

1. `系统调用`。提供特定的用户空间与内核空间的信息传递。
2. `信号`。内核空间出现一些异常时候会发送信号给进程，如SIGSEGV、SIGILL、SIGPIPE等。
3. `/proc`。proc可以读取内核空间的配置信息和运行状态并且设置部分属性的值。
4. `文件`。可以通过指定文件的读写操作来实现通信，但是流程不够实时，需要循环检测来实现。
5. `netlink`。类似socket通信方式，可以读写大量的数据，实现稍微复杂。
6. `ioctl`。可以实现数据量比较少时候的通信。
