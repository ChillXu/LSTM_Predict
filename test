



### 中断

CPU在执行当前程序时，由于系统出现了某种需要处理的紧急情况，CPU暂停正在执行的程序，保留现场后转去执行另一段特殊程序来处理出现的紧急事务，处理结束后CPU自动返回到原先暂停的程序中去继续执行，这种执行过程由于外界的的原因被中间打断的情况成为中断。



中断的作用：

+ 中断使得计算机系统具备应对对处理突发事件的能力，提高了CPU的工作效率，如果没有中断系统，CPU就只能按照原来的程序编写的先后顺序，对各个外设进行查询和处理，不能及时响应紧急事件。
+ 中断是系统自我保护的一种机制。为了防止程序运行出现错误运行状况而导致的电脑处理死循环而当机，特有的保护措施，当程序运行时检测程序检测出该程序运行超出正常值范围或长时间处于同一字段内运行，启动中断机制。
+ 内核与硬件通信的方式：轮询和中断。轮询速度太慢，中断被大量采用。



##### a. 中断分类

1. 外部中断
   + 不可屏蔽中断：通过INTR线向CPU请求的中断，主要来自外部设备如硬盘，打印机，网卡等。此类中断并不会影响系统运行，可随时处理，甚至不处理，所以名为可屏蔽中断。
   + 可屏蔽中断：通过NMI线向CPU请求的中断，如电源掉电，硬件线路故障等。这里不可屏蔽的意思不是不可以屏蔽，不建议屏蔽，而是问题太大，屏蔽不了，不能屏蔽的意思。

2. 内部中断
   + 陷阱：是一种有意的，预先安排的异常事件，一般是在编写程序时故意设下的陷进指令，而后执行到陷阱指令后，CPU将会调用特定程序进行相应的处理，处理结束后返回到陷阱指令的下一条指令。如`系统调用`，`程序调试功能`等。（`printf函数`最底层的实现中会有一条int 0x80指令，这就是一条陷阱指令，使用0x80号中断进行系统调用）
   + 故障：故障是在引起故障的指令被执行，但还没有执行结束时，CPU检测到的一类的意外事件。出错时交由故障处理程序处理，如果能处理修正这个错误，就将控制返回到引起故障的指令即CPU重新执这条指令。如果不能处理就报错。（`缺页`）
   + 终止：执行指令的过程中发生了致命错误，不可修复，程序无法继续运行，只能终止，通常会是一些硬件的错误。终止处理程序不会将控制返回给原程序，而是直接终止原程序。



##### b. 中断过程

+ 中断请求
+ 中断响应
+ 保护现场（压栈）
+ 定位中断服务程序
+ 中断处理
+ 中断返回（出栈）



### Linux-fork创建子进程

1. 为什么要创建子进程
   + 每一次程序运行都需要一个进程
   + 多个进程实现宏观上的并行

2. fork的内部原理
   + 进程的分裂生长模式。如果操作系统需要一个新进程来运行一个程序，那么操作系统会用一个现有的进程来复制生成一个新的进程。
   + fork函数调用一次会返回两次，返回值等于0的就是子进程，而返回值大于0的就是父进程。
   + 典型的使用fork的方法：使用fork后然后用if判断返回值，并且返回值大于0时就是父进程，等于0时就是子进程。
   + fork的返回值在子进程中等于0，在父进程中等于本次fork创建的子进程的进程ID。

3. 关于子进程
   + 子进程有自己独立的PCB
   + 子进程被内核同等调度

4、父子进程对文件的操作

（1）、子进程继承父进程中打开的文件

　　a、父进程先open打开一个文件得到fd，然后在fork创建子进程。之后在父子进程中各自write向fd中写入内容

　　b、测试结论：接续写。实际上本质原因是父子进程之间的fd对应的文件指针是彼此关联的（特别像O_APPEND标志后的样子）

5、父子进程各自独立打开同一文件实现共享

（1）、父进程open打开1.txt然后写入，子进程打开1.txt然后写入，结论是：分别写。

原因是父子进程分离后才各自打开的1.txt，这个时候两个进程的PCB已经独立了，文件表也独立了，因此2次读写是完全独立的。

（2）、open时使用O_APPEND标志后，实际测试结果表明O_APPEND标志可以把父子进程各自独立打开的fd的文件指针给关联起来，实现分别写。

6、总结：

（1）、父进程在没有fork之前自己做的事情对子进程有很大影响，但是父进程在fork之后，在自己的if里做的事情就对子进程没有影响了。本质原因就是因为fork内部实际上已经复制父进程的PCB生成一个新的子进程，并且fork返回时子进程已经完全和父进程脱离并且独立的被操作系统OS调度执行了。

（2）、子进程的最终目的是要独立的去运行另外的程序。
