# TEMP

### 1. 在main执行之前和之后执行的代码

**main函数执行之前**，主要就是初始化系统相关资源：

- 设置栈指针
- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容
- 全局对象初始化，在`main`之前调用构造函数
- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
- `__attribute__((constructor))`修饰的函数

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行；
-  `atexit` 注册的函数，它会在main 之后执行;
- `__attribute__((destructor))`修饰的函数

https://blog.csdn.net/stone8761/article/details/122498016



### 2. 堆快还是栈快

栈快一点。

因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。



### 3. 区别以下指针类型

```c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。



### 4. 既然有了malloc/free，C++中为什么还需要new/delete呢？

- malloc/free和new/delete都是用来申请内存和回收内存的。
- 在对`非基本数据类型的对象`使用的时候，对象创建的时候还需要`执行构造函数`，销毁的时候要执行`析构函数`。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。



### 5. 被free回收的内存是立即返还给操作系统吗？

不是的，被free回收的内存会首先被ptmalloc（内存管理器）使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。



### 宏定义 & 函数

- 宏在**预处理**阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏定义不是语句，不要在最后加分号。



### 宏定义 & typedef

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，`typedef char* p_char`和`#define p_char char*`区别巨大。（**同时定义多个变量的时候有区别**，主要区别在于这种使用方式：
  `p_char a,b;` 前者，a，b 都是char *类型；后者，a是char *类型，b是char类型）



### 变量声明 & 定义

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并`不分配内存空间`；定义要在定义的地方为其分配存储空间。
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。



### strlen & sizeof

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据；strlen的参数只能是字符指针且结尾是`'\0'`的字符串。
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。

```c++
  int main(int argc, char const *argv[]){
      
      const char* str = "name";

      sizeof(str); // 取的是指针str的长度，是8
      strlen(str); // 取的是这个字符串的长度，不包含结尾的 \0。大小是4
      return 0;
  }
```



### 一个指针占多少字节？

在64位的编译环境下的，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大小跟编译环境有关，而与机器的位数无关。



### a和&a有什么区别？

假设数组`int a[10];` `int (*p)[10] = &a;`

- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。`*(a + 1) = a[1]`。
- &a是数组的指针，其类型为`int (*)[10]`（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。
- 若`(int *)p`，此时输出*p时，其值为a[0]的值，因为被转为`int *`类型，解引用时按照int类型大小来读取。



### C++ & Python的区别

- Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。
- Python使用缩进来区分不同的代码块，C++使用花括号来区分。
- C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等。
- Python的库函数比C++的多，调用起来很方便。



### C++ & C的区别

- C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
- 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
- C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
- C++中的try/catch/throw异常处理机制取代了标准C中的`setjmp()`和`longjmp()`函数。
- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。
- C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。
- 在C++中，不允许定义多个同名的全局变量。C语言中多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
- 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等



### 15. struct 和 class

1. 总的来说，struct 更适合看成是一个**数据结构的实现体**，class 更适合看成是一个**对象的实现体**。两者都拥有成员函数、公有和私有部分。任何可以使用class完成的工作，同样可以使用struct完成。
2. 最本质的一个区别就是**默认的访问控制**

   + 默认的继承访问权限。struct 是 public 的，class 是 private 的。

   + struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。



### 拷贝初始化 & 直接初始化

当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：

+ 直接初始化直接调用与实参匹配的构造函数。
+ 拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。

```c++
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化
string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3
string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```

**为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了**（语句1和语句3等价）。

- 当拷贝构造函数为private时：语句3和语句4在编译时会报错
- 使用explicit修饰构造函数时：编译时会报错



### 初始化 & 赋值的区别

- 对于简单类型来说，初始化和赋值没什么区别
- 对于类和复杂数据类型来说，这两者的区别就大了

```c++
class A{
public:
    int num1;
    int num2;
public:
    A(int a=0, int b=0):num1(a),num2(b){};
    A(const A& a){};
    //重载 = 号操作符函数
    A& operator=(const A& a){
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main(){
    A a(1,1);
    A a1 = a; //拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2
    return 0;
}
```



### 野指针 & 悬空指针

都是是指向无效内存区域（这里的无效指的是"不安全不可控"）的指针，访问行为将会导致未定义行为。

+ 野指针，指的是没有被初始化过的指针。
+ 悬空指针，指针最初指向的内存已经被释放了的一种指针。

**产生原因及解决办法：**

野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。



### C和C++的类型安全

##### 1. 什么是类型安全？

类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。

##### 2. C的类型安全

C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。

- printf格式输出

`printf("浮点类型输出：%f\n",10);`

- malloc函数的返回值

malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，常常有这样的用法`char* pStr=(char*)malloc(100*sizeof(char))`，这里明显做了显式的类型转换。但是`int* pInt=(int*)malloc(100*sizeof(char))`就很可能带来一些问题，而这样的转换C并不会提示错误。

##### 3. C++的类型安全

相比于C语言，C++提供了一些新的机制保障类型安全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*；
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
- C++提供了**dynamic_cast**关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。

>应尽量避免使用空类型指针void*，尽量不对两种类型指针做强制转换。



### 重载、覆写 & 隐藏

##### 1. 重载（overload）

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是`函数名相同，参数类型和数目有所不同`，**不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数**。重载和函数成员是否是虚函数无关。

##### 2. 覆写（override）

重写指的是在派生类中覆盖基类中的同名函数，**重写就是重写函数体**，**要求基类函数必须是虚函数**且：

- 与基类的虚函数有相同的参数个数
- 与基类的虚函数有相同的参数类型
- 与基类的虚函数有相同的返回值类型

==重载与重写的区别：==

- 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系；
- 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求；
- 重写关系中，调用方法根据**对象类型决定**，重载根据调用时**实参表**与形参表的对应关系来选择函数体。

##### 3. 隐藏（hide）

隐藏指的是某些情况下，`派生类中的函数屏蔽了基类中的同名函数`，包括以下情况：

+ 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。

```c++
//父类
class A{
public:
    void fun(int a){
		cout << "A中的fun函数" << endl;
	}
};
//子类
class B : public A{
public:
    //隐藏父类的fun函数
    void fun(int a){
		cout << "B中的fun函数" << endl;
	}
};
int main(){
    B b;
    b.fun(2); //调用的是B中的fun函数
    b.A::fun(2); //调用A中fun函数
    return 0;
}
```

+ 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。

```c++
//父类
class A{
public:
    virtual void fun(int a){
		cout << "A中的fun函数" << endl;
	}
};
//子类
class B : public A{
public:
    //隐藏父类的fun函数
   virtual void fun(char* a){
	   cout << "A中的fun函数" << endl;
   }
};
int main(){
    B b;
    b.fun(2); //报错，调用的是B中的fun函数，参数类型不对
    b.A::fun(2); //调用A中fun函数
    return 0;
}
```

