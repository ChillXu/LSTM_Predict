
### 30. 锁机制存在的问题

+ `效率问题`。锁机制的实现需要对内存的原子化访问，这种访问操作会破坏流水线操作，降低了流水线效率，这是影响性能的一个因素。另外，在采用读写锁机制的情况下，`写锁是排他锁，无法实现写锁与读锁的并发操作`，在某些应用下会降低性能。

+ `扩展性问题`。例如，当系统中CPU数量增多的时候，采用锁机制实现数据的同步访问效率偏低。并且随着CPU数量的增多，效率降低，由此可见锁机制实现的数据一致性访问扩展性差。



### 31. 原子操作

原子操作：不可中断的一个或者一系列操作，也就是不会被线程调度机制打断的操作，运行期间不会有任何的上下文切换（context switch）。

`原子操作主要用于实现资源计数。`

1. **设置原子变量的值**

```c
void atomic_set(atomic_t *v, int i); //设置原子变量的值为 i 

atomic_t v = ATOMIC_INIT(0); //定义原子变量 v 并初始化为 0 
```

2. **获取原子变量的值**

```c
atomic_read(atomic_t *v); //返回原子变量的值
```

3. **原子变量加/减**

```c
void atomic_add(int i, atomic_t *v); //原子变量增加 i 

void atomic_sub(int i, atomic_t *v); //原子变量减少 i 
```

4. **原子变量自增/自减**

```c
void atomic_inc(atomic_t *v); //原子变量增加 1 

void atomic_dec(atomic_t *v); //原子变量减少 1 
```

5. **操作并测试**

```c
int atomic_inc_and_test(atomic_t *v); 

int atomic_dec_and_test(atomic_t *v); 

int atomic_sub_and_test(int i, atomic_t *v); 
```

上述操作对原子变量执行自增、自减和减操作后测试其是否为 0， 为 0 则返回 true，否则返回 false。



##### 互斥锁和原子锁的区别

严格来说互斥锁是一个数据结构，是写代码开发人员人为约束的一种都要遵循的一系列操作。 原子操作是单个不可被打断的操作，没有其他线程可以打断它。

+ 原子操作的优势：更加轻量，可以在不形成临界区的情况下完成并发安全的值的替换操作。可以大大减少同步对程序性能的消耗。
+ 原子操作的劣势：原子操作是乐观的，总是假设操作未被改变，在被操作的值被频繁改变的情况下，原子操作并不那么容易成功，而使用互斥锁总是趋于悲观，我们总是假设会有并发的操作要修改被操作的值，因此使用锁对一系列操作加上临界区保护。

1. 互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。

2. 原子操作是针对某个值的单个互斥操作。

3. `互斥锁是悲观锁`，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。

> **悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
>
> **乐观锁**：假设不会发生并发冲突，每次不加锁而是假设没有冲突而去完成某项操作，只在提交操作时检查是否违反数据完整性。



### 32.CAS & FAA

##### a. 锁机制存在的问题

- 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题；
- 一个线程持有锁会导致其它所有需要此锁的线程挂起；
- 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。

volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。



##### b. CAS（Compare and Swap）

**先比较，再交换**

CAS是解决多线程并行情况下使用锁造成性能损耗的一种机制。

- CAS操作包含三个操作数——`内存位置(V)`、`预期原值(A)`、`新值(B)`。
- 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值；否则，处理器不做任何操作。
- 无论哪种情况，它都会在CAS指令之前返回该位置的值。

```c
bool compare_and_swap (int *addr, int oldval, int newval)
{
  if ( *addr != oldval ) {
      return false;
  }
  *addr = newval;
  return true;
}
```

**CAS的ABA问题**：

- 进程P1在共享变量中读到值为A
- P1被抢占了，进程P2执行
- P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占
- P1回来看到共享变量里的值没有被改变，于是继续执行。

**解决思路**：增加版本号，每次变量更新时把版本号+1，A-B-A就变成了1A-2B-3A，`在compare阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致`。



##### c. FAA（Fetch And Add）

**先取值，然后进行增加**

FAA将存储位置的内容增加指定的值（原子操作），其他线程无法观测中间结果。

FAA特点就是原子性，因为在多处理器的计算中进行x=x+a的操作，实际上有三步：

1. 获取变量x的地址，把x的值放到寄存器中
2. 在寄存器增加a
3. 把寄存器的新值放到x的地址中。

`FAA的意义就是把这三步原子化，要么都执行要么都不执行。`

```c
int FetchAndAdd(int* addr, int inc) {
    int value = *addr
    *addr = value + inc
    return value
}
```

**FFA的存在的问题**：

FFA的使用场景比较局限（自增自减的场景如计数器）。



### 33. RCU锁

RCU（Read Copy Update）针对`读多写少`设计的进程数据同步机制。RCU的读者不加锁，只有写者加锁，性能比锁机制更高。

**基本概念：**

+ `读(Read)`：读者不需要获得任何锁就可访问RCU保护的临界区；
+ `拷贝(Copy)`：写者在访问临界区时，写者“自己”将先拷贝一个临界区副本，然后对副本进行修改；
+ `更新(Update)`：RCU机制将在在适当时机使用一个回调函数把指向原来临界区的指针重新指向新的被修改的临界区，锁机制中的垃圾收集器负责回调函数的调用。（时机：所有引用该共享临界区的CPU都退出对临界区的操作。即没有CPU再去操作这段被RCU保护的临界区后，这段临界区即可回收了，此时回调函数即被调用）

- `静默态QS(Quiescent State)`：一种描述临界区资源的状态，在这种状态下没有用户进程访问临界区资源。
- `宽限期GP(Grace Period)`：写者等待所有读者资源访问结束的这段时间。宽限期也是一个更通用的术语，表示当写者经过宽限期之后，它修改的临界区资源不再有读者访问。



### 34. 底层IO模型







### C++从代码到可执行程序经历了什么

125









1. 底层IO模型，阻塞，非阻塞，信号，多路复用，异步
2. 多线程vs多进程；同一进程线程切换，不同进程线程切换
3. 协程vs线程
4. inode，软连接、硬连接，文件描述符
5. 零拷贝



线程安全

健康成长天线宝宝啊个人主页：https://www.nowcoder.com/profile/2765647?noredirect=true

### 用户空间和内核空间通信的几种方式

1、系统调用，提供特定的用户空间与内核空间的信息传递。

2、信号，内核空间出现一些异常时候会发送信号给进程，如SIGSEGV、SIGILL、SIGPIPE等。

3、/proc，proc可以读取内核空间的配置信息和运行状态并且设置部分属性的值。

4、文件，可以通过指定文件的读写操作来实现通信，但是流程不够实时，需要循环检测来实现。

5、netlink，类似socket通信方式，可以读写大量的数据，实现稍微复杂。

6、ioctl，可以实现数据量比较少时候的通信。
