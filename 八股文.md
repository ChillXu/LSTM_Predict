# 计算机网络

### 1. TCP首部格式

![TCP首部](Pics/TCP首部.png)

- 源端口号（16bit）：表示发送端端口号。
- 目的端口号（16bit）：表示接收端端口号。
- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。是指下一次应该收到的数据的序号，表示已收到确认号前一位为止的数据。
- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
- 保留（4bit）：为了以后扩展时使用，一般设置为0。
- 标志位（6bit）：
  - CWR：Congestion Window Reduced，ECE标志为1时，则通知对方已将拥塞窗口缩小。
  - ECE：ECN-Echo，置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。
  - URG：标志紧急指针是否有效。该位位1时，表示包中有需要紧急处理的数据。
  - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
  - PSH：提示接收端立即从缓冲读走数据。该位为1时，表示需要将收到的数据立刻传给上层应用协议。
  - RST：表示要求对方重新建立连接（复位报文段）。该位为1时，表示TCP连接中出现异常必须强制断开连接。（程序宕掉、切断电源等原因导致主机重启，所有连接信息将全部被初始化）
  - SYN：表示请求建立一个连接（连接报文段）。SYN为1表示希望建立连接，并在其序号的字段进行序号初始值的设定。
  - FIN：表示关闭连接（断开报文段）。
- 窗口大小（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。
- 紧急指针（16bit）：从数据部分的首位到紧急指针所指示的位置为止为紧急数据。
- 选项：用于提高TCP的传输性能。



### 2. UDP首部格式

![UDP首部](Pics/UDP首部.png)



+ 源端口号（16bit）：表示发送端端口号。
+ 目的端口号（16bit）：表示接收端端口号。
+ 长度（8bit）：保存UDP首部的长度跟数据的长度之和。
+ 校验和（16bit）：接收主机在收到UDP数据报以后，从IP首部获知IP地址信息构造UDP伪首部，在进行校验和计算。

==引入伪首部是为了验证一个通信中必要的5项识别码是否正确，“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。==



### 3. IP数据报格式

![IP 数据报格式](Pics/IP数据报.png)



+ 版本（4bit）：标识IP首部的版本号。（IPv4的版本号为4）
+ 首部长度（4bit）：表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为5，长度为20字节。
+ 服务类型（8bit）：表明服务质量。
+ 总长度（16bit）：表示IP首部与数据部分合起来的总字节数。因此IP包的最大长度为65535（=2^16^）字节。
+ 标识（16bit）：用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。
+ 标志（3bit）：表示包被分片的相关信息。
+ 片偏移（13bit）：用来标识被分片的每一个分段相对于原始数据的位置。
+ 生存时间（TTL：Time To Live，8bit）：指可以中转多少个路由器，每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。
+ 协议（8bit）：表示IP包传输层的上层协议编号。
+ 首部校验和（16bit）：用来确保IP数据报不被破坏。
+ 源地址（32bit）：发送端IP地址。
+ 目标地址（32bit）：接收端IP地址。
+ 可选项
+ 填充
+ 数据：存入数据。将IP上层协议的首部也作为数据进行处理。



### 4. TCP三次握手

![TCP三次握手](Pics/TCP三次握手.png)

##### a. 过程

1. 客户端发送 SYN 给服务器，说明客户端请求建立连接；
2. 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；
3. 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；
4. 服务端收到客户端的 ACK，连接已建立，可以数据传输。

##### b. TCP为什么要进行三次握手？

因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

##### c. 三次握手过程中可以携带数据吗？

第一次、第二次握手不可以携带数据，第三次可以。第三次握手时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。

（假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。）



### 5. TCP四次挥手

![TCP四次挥手](Pics/TCP四次挥手.png)

##### a. 过程

1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
4. 服务端继续发送之前没发完的数据给客户端；
5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；
7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

##### b. TCP为什么要进行四次挥手？

因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

##### c. 为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）。而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

##### d. 为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。



### 6. TCP连接状态

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
- FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

==**客户端的状态可以用如下的流程来表示：**== 
==**CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED**==

==**服务器的状态可以用如下的流程来表示：**== 
==**CLOSED->LISTEN->SYN-RECEIVED->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED**==



### 7. TCP的四种定时器

 对于每个连接，TCP管理4个不同的定时器。

1. **重传定时器：适用于希望收到另一端的确认ACK。**（发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到刚才发送数据的ACK确认报文，则对该报文进行重传）

2. **坚持定时器：使窗口大小信息保持不断流动。**（发送方收到接收方发来的一个窗口为0的ACK，此时启用坚持定时器；在定时器溢出之前还没有收到一个窗口扩大的ACK，此时发送方发送窗口探查报文；如果在规定的时间内仍然没有收到窗口扩大的ACK，此时会隔断时间发送一个窗口探查报文，直到窗口打开或者连接被终止）

3. **保活定时器：让服务器检测到半开放的TCP连接。**（客户端宕机或者重启导致TCP连接处于半开放状态）

4. **2MSL定时器：第四次挥手中假设ACK丢失的情况。**（Maximum Segment Lifetime 报文最大生存时间）



### 8. TCP长肥管道

带宽延时积很大的网络叫做长肥网络(LFN，long fat network，单位为字节)，在LFN上建立的TCP连接叫做长肥管。

# 操作系统

### 进程与线程

+ 进程是资源分配的基本单位，线程是资源调度的基本单位





























# C++

### 1. auto、auto& 和 const auto&

**auto :** `for(auto x:range)`会拷贝一份range元素，对x的操作不会修改range中的元素

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    vector<int> range={1,2,3,4,5};
    for(auto x:range){
        x=x+1;
    }
    return 0;
}
//range(1,2,3,4,5)
```

**auto& :** `for(auto& x:range)`修改了原容器中元素的值，&代表引用，不会拷贝

**auto&& :** `for(auto&& x:range)`也可以修改元素的值（一般用这种方法），不会拷贝

**const auto& :** `for(const auto& x:range)`只能读取range中的元素，不可修改

**const auto :** `for(const auto x:range)`只拷贝元素，不可修改拷贝出来的值

**Tips：auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低**



### 2. const

##### a. 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；**（没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰）**
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

==记忆：被 const 修饰（在 const 后面）的值不可改变，p2、p3==

##### b. 使用

```c++
// 类
class A{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化
public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function(){
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```



### 3. 宏定义 #define 和 const 常量

|    宏定义 #define    |   const 常量   |
| :------------------: | :------------: |
|    相当于字符替换    |    常量声明    |
|     预处理器处理     |   编译器处理   |
|    无类型安全检查    | 有类型安全检查 |
|      不分配内存      |   要分配内存   |
|     存储在代码段     |  存储在数据段  |
| 可通过 `#undef` 取消 |    不可取消    |

**预处理器：真正的编译开始之前由编译器调用的独立程序**

**类型安全：访问可以被授权访问的内存位置**



### 4. static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，**在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，**表明函数的作用范围，仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，**修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员**。
4. 修饰成员函数，**修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员**。



### 5. this指针

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针，它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。



### 6. inline 内联函数

##### a. 特征

- 相当于把内联函数里面的内容写在调用内联函数处；
- **相当于不用执行进入函数的步骤，直接执行函数体**；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中**定义**的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

##### b. 使用

```c++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

##### c. 优点

1. 内联函数同宏函数一样将**在被调用处进行代码展开**，**省去了参数压栈、栈帧开辟与回收，结果返回等**，从而提高程序运行速度；
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会；
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能；
4. 内联函数在运行时可调试，而宏定义不可以。

##### d. 缺点

1. **代码膨胀**。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. **inline 函数无法随着函数库升级而升级**。inline函数的改变需要重新编译，不像 non-inline 可以直接链接；
3. 是否内联，**程序员不可控**。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

> **虚函数（virtual）可以是内联函数（inline）吗？**
>
> - 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联
> - 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联
> - `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```



### 7. volatile

```
volatile int i = 10; 
```

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以**使用 volatile 告诉编译器不应对这样的对象进行优化**。
- volatile 关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile



### 8. assert()

断言，是宏，而非函数。

assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，**其作用是如果它的条件返回错误，则终止程序执行**。

可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

```c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```



### 9. sizeof()

- sizeof 对数组，得到整个数组所占空间大小
- sizeof 对指针，得到指针本身所占空间大小



### 10. #pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐

```c++
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1; 			//(1)+3
    double m4;   	//(8)
    int m3;				//(4)
};

#pragma pack(pop)   // 恢复对齐状态
```



### 11. 结构体内存对齐

- 结构体内成员按照声明顺序存储

- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）

- 结构体的内存大小为**有效对齐值**的整数倍，不足的需要补齐

- 当结构体嵌套了结构体时，作为数据成员的结构体的自身长度作为外部结构体的最大成员的内存大小，比如结构体a嵌套结构体b，b中有char、int、double等，则b的自身长度为8

  ```c++
  struct TestStructA{
      char d;//16
      int e;//20-23
      short f;//24-25
      double g;//32-39
  }structA;
  
  struct TestStructB{
      char a;//0
      int b;//4-7
      short c;//8-9
      struct TestStructA sturctA_1;
  }structB;
  
  int main(){
      cout<<sizeof(structB)<<endl;//40 按8字节对齐
      return 0;
  }
  /**
  *   0   1   2   3   4   5   6   7
  *  |a|        |         b         |
  *   8   9   10  11  12  13  14  15
  *  |  c   |
  *   16  17  18  19  20  21  22  23   
  *  | d |
  */
  ```

  

  **==目的==：** 
  
  **a. 程序的执行效率提高** （一般情况，CPU以字节大小（32位处理器4个字节）访问数据，如果数据没有内存对齐，CPU访问这些数据时，可能需要执行多次的读取操作，为了让CPU能一次获取到数据，从而提升性能）
  
  **b. 访问范围提高** 
  
  **c. 原子性的保障** （CPU 每次访问数据的宽度是一个字，要么完整地被执行,要么完全不执行）



### 12.位域

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

```c++
include <stdio.h>

int main(){
  
	//1.位域允许我们使用内存最小单位BIT位来存储数据,某些情况下可以为我们节省内存
	//2.位域是以数据类型来区分区域的,几种数据类型就表示有几个位域段( 未指定占用位,除外 )
	//3.同种位域类使用BIT位超过该位域数据类型大小自动完后继续占用该位域数据类型大小
	//4.未用完的BIT位还是要占用内存空间的即不存在只使用int类型的其中4位,后面28位还是要占用空间的
	//5.无法对位域成员变量取地址操作,因为我们无法取得某个BIT位的地址
	//6.位域一般使用unsigned数据类型
	//7.未指定占用位默认占用所有位数
	//8.位域遵循结构体对齐原则

struct Test
{
	//
	//第一个位域区域为int可以用空间位数为sizeof( int ) * 8 = 32位
	//刚好用完32位( 如果超过32位则自动往后移动32位即整个占用64位内存8字节大小 )
	unsigned int a:4;	//占用4位( 范围 0 - 2^4 -1 )
	unsigned int b:5;	//占用5位( 范围 0 - 2^5 -1 )
	unsigned int c:3;	//占用3位( 范围 0 - 2^3 -1 )
	unsigned int d:16;	//占用16位( 范围 0 - 2^16 -1 )
	//
	
	//
	//第二个位域区域为char可以用空间位数为sizeof( char ) * 8 = 8位
	//使用位数12位超过8位则自动往后移动8位即整个占用16位内存2字节大小 )
	unsigned char e:5;	//占用5位( 范围 0 - 2^5 -1 )
	unsigned char f:7;	//占用7位( 范围 0 - 2^7 -1 )
	//
 
	//
	//第三个位域区域为short可以用空间位数为sizeof( short ) * 8 = 16位
	//刚好用完16位
	unsigned short g:10;
	unsigned short h:6;
 
	//
	//第四个位域区域为char可以用空间位数为sizeof( char ) * 8 = 8位
	//未指定占用位数默认占用所有位数
	unsigned char i;
};

//整个结构体位域占用4 + 2 + 2 + 1 = 9个字节
//因为存在字节对齐则实际占用12个字节
Test t = {};
 
//不能这样使用
//unsigned int *p = &t.a;
 
const int size = sizeof( Test );
printf( "位域大小:%d字节\n", size );
return 0;
}
```


### 13. extern "C"

1. extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。也就是说，在一个文件中定义了变量和函数，在其他文件中要使用它们，可以有两种方式：使用头文件，然后声明它们，然后其他文件去包含头文件；在其他文件中直接extern。
2. `extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

```c++
#ifdef __cplusplus		//如果是被c++文件引用的话，extern "C"就会生效，否则extern "C"不生效
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```



### 14. struct 和 typedef struct

1. 如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索**全局标识符表**，`Student` 未找到，则搜索**类标识符**。即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：

```c++
// cpp
struct Student { 
    int age; 
};

void f( Student me );       // 正确，"struct" 关键字可省略
```

2. 若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：

```c++
typedef struct Student { 
    int age; 
} S;

void Student() {}           // 正确，定义后 "Student" 只代表此函数

//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名

int main() {
    Student(); 
    struct Student me;      // 或者 "S me";
    return 0;
}
```



### 15. struct 和 class

1. 总的来说，struct 更适合看成是一个**数据结构的实现体**，class 更适合看成是一个**对象的实现体**。

2. 最本质的一个区别就是**默认的访问控制**

   + 默认的继承访问权限。struct 是 public 的，class 是 private 的。

   + struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。



### 16. union 联合

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

```c++
#include<iostream>

union UnionTest {
    UnionTest() : i(10) {};
    int i;
    double d;
};

static union {	// 全局匿名联合
    int i;
    double d;
};

int main() {
    UnionTest u;

    union {			// 局部匿名联合
        int i;
        double d;
    };

    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10

    ::i = 20;
    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20

    i = 30;
    std::cout << i << std::endl;    // 输出局部匿名联合的 30

    return 0;
}
```



### 17. explicit（显式）关键字

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

```c++
struct A
{
	A(int) { }
	operator bool() const { return true; }
};

struct B
{
	explicit B(int) {}
	explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
	A a1(1);		// OK：直接初始化
	A a2 = 1;		// OK：复制初始化
	A a3{ 1 };		// OK：直接列表初始化
	A a4 = { 1 };		// OK：复制列表初始化
	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
	doA(1);			// OK：允许从 int 到 A 的隐式转换
	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a6(a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

	B b1(1);		// OK：直接初始化
	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
	B b3{ 1 };		// OK：直接列表初始化
	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

	return 0;
}
```



### 18. friend 友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制



### 19. using

+ using 声明

```c++
using std::cin;
```

+ using 指示

```c++
using namespace std;
```

+ 构造函数的 using 声明

在 C++11 中，派生类能够重用其**直接基类**定义的构造函数，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数

```c++
class Derived : Base {
public:
    using Base::Base;
    /* ... */
};
```



### 20. :: 范围解析运算符

1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间；
2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的；
3. 命名空间作用域符（`namespace::name`）：用于表示指定类型的作用域范围是具体某个命名空间的。

```c++
int count = 11;         // 全局（::）的 count

class A {
public:
	static int count;   // 类 A 的 count（A::count）
};
int A::count = 21;

void fun()
{
	int count = 31;     // 初始化局部的 count 为 31
	count = 32;         // 设置局部的 count 的值为 32
}

int main() {
	::count = 12;       // 测试 1：设置全局的 count 的值为 12
	A::count = 22;      // 测试 2：设置类 A 的 count 为 22
	fun();		        // 测试 3
	return 0;
}
```


### 21. enum 枚举类型

##### a. 限定作用域的枚举类型

```c++
enum class color {red, yellow, green};
color a = green;			// 错误，限定作用域的枚举成员在类型外不可访问
color a = color::green;		
```

##### b. 不限定作用域的枚举类型

```c++
enum color {red, yellow, green};
color a = green;			// 不限定作用域的枚举类型外可以使用枚举成员

enum {floatPrec = 6, doublePrec = 10};
```



### 22. decltype

decltype 关键字用于**选择并返回操作数的数据类型**。



### 23. 引用

##### a. 左值引用

非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。

```c++
int a=10;              //非常量左值（有确定存储地址，也有变量名）
const int a1=10;       //常量左值（有确定存储地址，也有变量名）
const int a2=20;       //常量左值（有确定存储地址，也有变量名）
 
//非常量左值引用
int &b1=a;         //正确，a是一个非常量左值，可以被非常量左值引用绑定
int &b2=a1;        //错误,a1是一个常量左值，不可以被非常量左值引用绑定
int &b3=10;        //错误，10是一个非常量右值，不可以被非常量左值引用绑定
int &b4=a1+a2;  //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定

//常量左值引用
const int &c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定
const int &c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定
const int &c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定
const int &c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定
```



##### b. 右值引用

非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。

主要目的：

- **消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。**
- 能够更简洁明确地定义泛型函数。

```c++
int a=10;             //非常量左值（有确定存储地址，也有变量名）
const int a1=20;      //常量左值（有确定存储地址，也有变量名）
const int a2=20;      //常量左值（有确定存储地址，也有变量名）

//非常量右值引用
int &&b1=a;         //错误，a是一个非常量左值，不可以被非常量右值引用绑定
int &&b2=a1;        //错误,a1是一个常量左值，不可以被非常量右值引用绑定
int &&b3=10;        //正确，10是一个非常量右值，可以被非常量右值引用绑定
int &&b4=a1+a2; //错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定

//常量右值引用
const int &&c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定
const int &&c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定
const int &&c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定
const int &&c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定
```



### 24. 宏

宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。



### 25. 成员初始化列表

- 更高效：少了一次调用默认构造函数的过程。
- 有些场合必须要用初始化列表：
  1. **常量成员**，因为常量只能初始化不能赋值，所以必须放在初始化列表里面；
  2. **引用类型**，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；
  3. **没有默认构造函数的类类型**，因为使用初始化列表可以不必调用默认构造函数来初始化。



### 26. 面向对象

面向对象三大特征 —— 封装、继承、多态

##### 1. 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- `public` 成员：可以被任意实体访问
- `protected` 成员：只允许被子类及本类的成员函数访问
- `private` 成员：只允许被本类的成员函数、友元类或友元函数访问

##### 2. 继承

- 基类（父类）——> 派生类（子类）

##### 3. 多态

- 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。
- 多态是以封装和继承为基础的。
- C++ 多态分类及实现：
  1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
  2. 子类型多态（Subtype Polymorphism，运行期）：虚函数
  3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
  4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换



**静态多态（编译期/早绑定）**

+ 函数重载

```c++
class A
{
public:
    void do(int a);
    void do(int a, int b);
};
```

**动态多态（运行期期/晚绑定）**

- 虚函数：用 virtual 修饰成员函数，使其成为虚函数
- 动态绑定：当使用**基类的引用或指针**调用一个虚函数时将发生动态绑定

```c++
class Shape                     // 形状类
{
public:
    virtual double calcArea()
    {
        ...
    }
    virtual ~Shape();
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
class Rect : public Shape       // 矩形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    Shape * shape2 = new Rect(5.0, 6.0);
    shape1->calcArea();         // 调用圆形类里面的方法
    shape2->calcArea();         // 调用矩形类里面的方法
    delete shape1;
    shape1 = nullptr;
    delete shape2;
    shape2 = nullptr;
    return 0;
}
```

- **可以将派生类的对象赋值给基类的指针或引用，反之不可**
- 普通函数（非类成员函数）不能是虚函数
- 静态函数（static）不能是虚函数
- **构造函数不能是虚函数**（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要<u>构造函数调用完成后才会形成虚表指针</u>）
- 内联函数不能是表现多态性时的虚函数



### 27. 虚析构函数
