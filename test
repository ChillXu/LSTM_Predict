### 3. 进程状态的切换

图片

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- 就绪状态（ready）：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- 运行状态（running）：进程正在处理器上上运行。
- 阻塞状态（waiting）：等待某资源为可用或等待 IO 操作完成。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

注意：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- `阻塞状态是缺少需要的资源`从而由运行状态转换而来，但是`该资源不包括 CPU 时间`，缺少 CPU 时间会从运行态转换为就绪态。



###  4. 进程调度算法

#### 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

##### a. 先来先服务（FCFS） first-come first-serverd

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

##### b. 短作业优先（SJF） shortest job first

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

##### c. 最短剩余时间优先（SRTN） shortest remaining time next

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

#### 2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

##### a. 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出**时钟中断**，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

**时间片轮转算法的效率和时间片的大小有很大关系：**

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png)



##### b. 优先级调度

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，`可以随着时间的推移增加等待进程的优先级`。

##### c. 多级反馈队列

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png)



### 5. 进程间通信

1. `管道/匿名管道(Pipes)`：只支持半双工通信（单向交替传输）；只用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. `有名管道(Names Pipes)` : 半双工通信；有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
3. `信号(Signal)` ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
4. `消息队列(Message Queuing)` ：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在**内核**中，只有在内核重启（即操作系统重启）或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。**
5. `信号量(Semaphores)` ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. `共享内存(Shared memory)` ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
7. `套接字(Sockets)` : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。



==因为进程是独立的，是操作系统提供的工作环境，要跟另外一个进程通信，那必段通过操作系统来实现(也就是所谓的系统调用) 不管是信号，管道还是共享内存。==



### 6. 进程同步











### 7. ※虚拟内存



虚拟内存：MMU/TLB，多级页表，内存分配（slab，伙伴）





















1. 虚拟内存：MMU/TLB，多级页表，内存分配（slab，伙伴）
2. 进程线程基本概念，PCB包含什么，进程内存模型，TCB
3. 进程间通信
   1. 基本概念、原理
   2. 通信效率，是否设计系统调用
4. 死锁，条件，检测/恢复/预防
5. 同步，原子操作，CAS&FAA，互斥锁，条件变量，RCU

CAS（Compare and Swap）先比较，再交换

FAA（Fetch And Add）先取值，然后进行增加

1. 底层IO模型，阻塞，非阻塞，信号，多路复用，异步
2. 多线程vs多进程；同一进程线程切换，不同进程线程切换
3. 协程vs线程
4. inode，软连接、硬连接，文件描述符
5. 零拷贝













