# 计算机网络

### 1. TCP首部格式

![TCP首部](Pics/TCP首部.png)

- 源端口号（16bit）：表示发送端端口号。
- 目的端口号（16bit）：表示接收端端口号。
- 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。
- 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。是指下一次应该收到的数据的序号，表示已收到确认号前一位为止的数据。
- 首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。
- 保留（4bit）：为了以后扩展时使用，一般设置为0。
- 标志位（6bit）：
  - CWR：Congestion Window Reduced，ECE标志为1时，则通知对方已将拥塞窗口缩小。
  - ECE：ECN-Echo，置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。
  - URG：标志紧急指针是否有效。该位位1时，表示包中有需要紧急处理的数据。
  - ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。
  - PSH：提示接收端立即从缓冲读走数据。该位为1时，表示需要将收到的数据立刻传给上层应用协议。
  - RST：表示要求对方重新建立连接（复位报文段）。该位为1时，表示TCP连接中出现异常必须强制断开连接。（程序宕掉、切断电源等原因导致主机重启，所有连接信息将全部被初始化）
  - SYN：表示请求建立一个连接（连接报文段）。SYN为1表示希望建立连接，并在其序号的字段进行序号初始值的设定。
  - FIN：表示关闭连接（断开报文段）。
- 窗口大小（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。
- 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。
- 紧急指针（16bit）：从数据部分的首位到紧急指针所指示的位置为止为紧急数据。
- 选项：用于提高TCP的传输性能。



### 2. UDP首部格式

![UDP首部](Pics/UDP首部.png)



+ 源端口号（16bit）：表示发送端端口号。
+ 目的端口号（16bit）：表示接收端端口号。
+ 长度（8bit）：保存UDP首部的长度跟数据的长度之和。
+ 校验和（16bit）：接收主机在收到UDP数据报以后，从IP首部获知IP地址信息构造UDP伪首部，在进行校验和计算。

==引入伪首部是为了验证一个通信中必要的5项识别码是否正确，“源IP地址”、“目标IP地址”、“源端口”、“目标端口”、“协议号”。==



### 3. IP数据报格式

![IP 数据报格式](Pics/IP数据报.png)



+ 版本（4bit）：标识IP首部的版本号。（IPv4的版本号为4）
+ 首部长度（4bit）：表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为5，长度为20字节。
+ 服务类型（8bit）：表明服务质量。
+ 总长度（16bit）：表示IP首部与数据部分合起来的总字节数。因此IP包的最大长度为65535（=2^16^）字节。
+ 标识（16bit）：用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。
+ 标志（3bit）：表示包被分片的相关信息。
+ 片偏移（13bit）：用来标识被分片的每一个分段相对于原始数据的位置。
+ 生存时间（TTL：Time To Live，8bit）：指可以中转多少个路由器，每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。
+ 协议（8bit）：表示IP包传输层的上层协议编号。
+ 首部校验和（16bit）：用来确保IP数据报不被破坏。
+ 源地址（32bit）：发送端IP地址。
+ 目标地址（32bit）：接收端IP地址。
+ 可选项
+ 填充
+ 数据：存入数据。将IP上层协议的首部也作为数据进行处理。



### 4. TCP三次握手

![TCP三次握手](Pics/TCP三次握手.png)

##### a. 过程

1. 客户端发送 SYN 给服务器，说明客户端请求建立连接；
2. 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；
3. 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；
4. 服务端收到客户端的 ACK，连接已建立，可以数据传输。

##### b. TCP为什么要进行三次握手？

因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

##### c. 三次握手过程中可以携带数据吗？

第一次、第二次握手不可以携带数据，第三次可以。第三次握手时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。

（假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。）



### 5. TCP四次挥手

![TCP四次挥手](Pics/TCP四次挥手.png)

##### a. 过程

1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
4. 服务端继续发送之前没发完的数据给客户端；
5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；
7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

##### b. TCP为什么要进行四次挥手？

因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

##### c. 为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

因为`客户端请求释放时，服务器可能还有数据需要传输给客户端`，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）。而`连接时则没有中间的数据传输`，因此连接时可以 ACK 和 SYN 一起发送。

##### d. 为什么客户端释放最后需要 TIME_WAIT 等待 2MSL 呢？

1. 为了`保证客户端发送的最后一个 ACK 报文能够到达服务端`。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
2. `防止已失效的连接请求报文段出现在本连接中`。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。`去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)，这恰恰就是2MSL(Maximum Segment Life）`。

##### e. TIME_WAIT时大量短连接怎么处理？

假设每秒建立了1000个短连接（Web场景下是很常见的，例如每个请求都去访问memcached），假设TIME_WAIT的时间是1分钟，则1分钟内需要建立6W个短连接，由于TIME_WAIT时间是1分钟，这些短连接1分钟内都处于TIME_WAIT状态，都不会释放，而Linux默认的本地端口范围配置是：net.ipv4.ip_local_port_range = 32768   61000
不到3W，因此这种情况下新的请求由于没有本地端口就不能建立了。

1. `可以改为长连接`，但代价较大，长连接太多会导致服务器性能问题；
2. `修改ipv4.ip_local_port_range，增大可用端口范围`，但只能缓解问题，不能根本解决问题；
3. `客户端程序中设置socket的SO_LINGER选项`；（设置 l_onoff为非0，l_linger为0，当调用close的时候，TCP连接会立即断开。send buffer中未被发送的数据将被丢弃，并向对方发送一个RST信息。值得注意的是，由于这种方式，不是以4次握手方式结束TCP链接，所以，TCP连接将不会进入TIME_WAIT状态，这样会导致新建立的可能和就连接的数据造成混乱。这种关闭方式称为“强制”或“失效”关闭。）
4. `客户端机器打开tcp_tw_recycle和tcp_timestamps选项`；（表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。）
5. `客户端机器打开tcp_tw_reuse和tcp_timestamps选项`；（允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。）
6. `客户端机器设置tcp_max_tw_buckets为一个很小的值`；（系统TIME_WAIT连接的最大数量）



### 6. TCP连接状态

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
- SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
- ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。
- FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

==**客户端的状态可以用如下的流程来表示：**== 
==**CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED**==

==**服务器的状态可以用如下的流程来表示：**== 
==**CLOSED->LISTEN->SYN-RECEIVED->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED**==



### 7. TCP的四种定时器

 对于每个连接，TCP管理4个不同的定时器。

1. **重传定时器：适用于希望收到另一端的确认ACK。**（发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到刚才发送数据的ACK确认报文，则对该报文进行重传）

2. **坚持定时器：使窗口大小信息保持不断流动。**（发送方收到接收方发来的一个窗口为0的ACK，此时启用坚持定时器；在定时器溢出之前还没有收到一个窗口扩大的ACK，此时发送方发送零窗口探查报文（一个字节）；如果在规定的时间内仍然没有收到窗口扩大的ACK，此时会隔断时间发送一个窗口探查报文，直到窗口打开或者连接被终止）

3. **保活定时器：让服务器检测到半开放的TCP连接。**（客户端宕机或者重启导致TCP连接处于半开放状态）

4. **2MSL定时器：第四次挥手中假设ACK丢失的情况。**（Maximum Segment Lifetime 报文最大生存时间）



### 8. TCP长肥管道

带宽延时积很大的网络叫做长肥网络(LFN，long fat network，单位为字节)，在LFN上建立的TCP连接叫做长肥管。



### 9. TCP流量控制（flow control）

##### a. 概念

接收方通过**TCP头窗口字段**告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。

##### b. 方法

利用可变窗口进行流量控制

![TCP流量控制](Pics/TCP流量控制.png)

- TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
  - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。
  - 接收窗：用来标记可以接收的数据大小。

- TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中`发送窗 = 已发送未确认部分 + 未发但可发送部分`。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。`接收窗 = 未接收但准备接收部分`。
- 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。

##### c. 发送窗口

<img src="Pics/发送窗口.jpeg" alt="发送窗口" style="zoom: 33%;" />

##### d. 接收窗口

<img src="Pics/接收窗口.jpeg" alt="接收窗口" style="zoom:33%;" />



[发送窗口&接收窗口](https://www.zhihu.com/question/50562171/answer/2300292882)



### 10. TCP拥塞控制

##### a. 概念

拥塞控制就是防止过多的数据注入到网络中，避免网络中的路由器或链路过载。

##### b. 方法

- `慢开始(slow-start)：`先试探网络拥塞程度再逐渐增大拥塞窗口。假设窗口长度为d，收到一个确认就加1，正好收到了d个确认，所以一共加d，正好是翻倍，直到达到阀值ssthresh，这部分是慢开始过程。

- `拥塞避免(congestion avoidance)：`达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将慢启动阀值设置为当时拥塞窗口一半的大小，再次慢启动。

- `快重传(fast retransmit)：`收到3个连续的重复确认，慢启动阈值设置为当时窗口大小的一半，然后快速重传。

- `快恢复(fast recovery)：`快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。

  + cwnd = cwnd + 3 *MSS（加3 MSS的原因是因为收到3个重复的ACK，先不降速再重传一次）ssthresh=cwnd/2

  + 重传DACKs指定的数据包（Duplicate ACK）
  + 如果再收到DACKs，那么cwnd大小增加一
  + 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法，将cwnd设置为ssthresh，然后进入拥塞避免算法

<img src="Pics/TCP拥塞窗口变化.png" alt="TCP拥塞窗口变化"  />

<img src="Pics/快重传.png" alt="快重传"  />

<img src="Pics/TCP拥塞控制流程图.png" alt="TCP拥塞控制流程图"  />



### 11. 为何快速重传3次ACK？

区分包的丢失是由于**链路故障**还是**乱序**等其他因素引发。

两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK！综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。

> 包的丢失原因：
>
> 1. 包checksum 出错
>
> 2. 网络拥塞
>
> 3. 网络断，包括路由重收敛



### 12. MTU & MSS

**MTU：maximum transmission unit，最大传输单元。**由硬件规定，如以太网的MTU为1500字节。

**MSS：maximum segment size，最大分节大小。**为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。（以太网标准MSS值为 1500-20-20=1460字节）



### 13. 如何区分流量控制和拥塞控制？

1. 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。

2. 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；

   拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据**探查网络状况后而自适应调整**。

3. 实际最终发送窗口 = min{流量控制发送窗口，拥塞窗口}。



### 14. 半连接 & 全连接

+ **半连接队列**：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里。

+ **全连接队列**：已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于**SYN-ACK 重传次数**的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......



### 15. TCP vs UDP

##### a. TCP

TCP（Transmission Control Protocol，传输控制协议）是一种`面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段`。

##### b. UDP

UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种`无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报`。

|           TCP            |                     UDP                      |
| :----------------------: | :------------------------------------------: |
|         面向连接         |                    无连接                    |
|         可靠交付         |       尽最大努力交付，即不保证可靠交付       |
|        全双工通信        |                  不可靠信道                  |
|         拥塞控制         |                 没有拥塞控制                 |
| 只能点对点（一对一）通信 | 支持一对一、一对多、多对一、多对多的交互通信 |
|        面向字节流        |                   面向报文                   |
|   首部开销大（20字节）   |             首部开销小（8字节）              |

> UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是加上首部后就交给了下面的网络层，无论应用层交给UDP多长的报文，它统统发送，一次发送一个。而接收方收到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小。
>
> TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着。TCP会根据当前网络的拥塞状态来确定每个报文段的大小。



### 16. TCP 如何保证可靠传输

- `确认和超时重传：`接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。
- `数据校验：`TCP报文头有校验和，用于校验报文是否损坏。
- `数据合理分片和排序：`TCP会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。（而UDP：IP数据报大于1500字节，大于MTU，这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。）
- `流量控制：`当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
- `拥塞控制：`当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。



### 17. TCP 封包&拆包

封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。（**发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包**）

- 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
- 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。



### 18. TCP 黏包问题

##### a. 原因

TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。

##### b. 解决

- `发送定长包`。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- `包头加上包体长度`。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
- `在数据包之间设置边界`，如添加特殊符号 `\r\n` 标记。FTP 协议正是这么做的，但问题在于如果数据正文中也含有 `\r\n`，则会误判为消息的边界。
- `使用更加复杂的应用层协议`（如RTMP协议）。



### 19. TCP & UDP应用场景

**TCP协议提供可靠的服务**，对于文件传输、远程终端这些应用来说，是不允许数据丢失的，因为TCP提供了超时与重传等可靠机制。

- 万维网（HTTP等）
- 文件传输（FTP等）
- 电子邮件（SMTP等）
- 远程终端接入等（TELNET等）

**UDP协议提供高效率的服务**，当包量比较少的时候使用UDP是比较适合的，因为这样可以避免丢失大量的重要数据；对于音视频通话来说，因为UDP是非连接的，所以占用资源比较少，并且对于音视频来说，丢掉一些数据包也是可以接受的。

+ 包量比较少的通信（DNS、SNMP等）

+ 音视频通话（即时通信等）

+ 广播通信（广播、多播）



### 20. HTTP协议

HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是WWW万维网的数据通信的基础，用于从 WWW 服务器传输超文本到本地浏览器的传送协议。

并且，`HTTP 是一个无状态（stateless）协议`，也就是说服务器不维护任何有关客户端过去所发请求的消息。有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。



### 21. HTTP 协议通信过程

HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：

1. 服务器在 80 端口等待客户的请求。
2. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
3. 服务器接收来自浏览器的 TCP 连接。
4. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
5. 关闭 TCP 连接。



### 22. HTTP请求方法

客户端发送的 **请求报文** 第一行为请求行，包含了方法字段。

HTTP1.0 定义了三种请求方法： GET、POST 和 HEAD方法。

HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 方法    | 意义                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求指定的页面信息，并返回实体主体                           |
| HEAD    | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 |
| OPTIONS | 请求一些选项信息，允许客户端查看服务器的性能                 |
| PUT     | 从客户端向服务器传送的数据取代指定的文档的内容               |
| PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新              |
| DELETE  | 请求服务器删除指定的页面                                     |
| TRACE   | 回显服务器收到的请求，主要用于测试或诊断                     |
| CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器      |



### 23. HTTP 常见状态码（Status-Code）

- 1xx（信息性状态码）：接收的请求正在处理
  - 100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
  - 101 Switching Protocols：切换协议，服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议
- 2xx（成功状态码）：请求正常处理完毕
  - 200 OK：请求被成功处理
  - **201 Created**：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。
  - **202 Accepted**：服务端已经接收到了请求，但是还未处理。
  - **204 No Content**： 服务端已经成功处理了请求，但是没有返回任何内容。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
  - **206 Partial Content**：表示客户端进行了范围请求（range request），响应报文包含由 Content-Range 指定范围**（该数据块的偏移量和数据块的长度）**的实体内容。
- 3xx（重定向状态码）： 需要进行附加操作以完成请求
  - 301 Moved Permanently：资源被永久重定向了。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL，今后任何新的请求都应使用新的 URL 代替。
  - **302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。
- 4xx（客户端错误状态码）：服务器无法处理请求
  - 400 Bad Request：请求报文中存在语法错误。
  - 401 Unauthorized：请求要求用户的身份认证。
  - 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）。
  - 404 Not Found：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。
  - 408 Request Timeout：服务器等待客户端发送的请求时间过长，超时。
- 5xx（服务器错误状态码）：服务器处理请求出错
  - 500 Internal Server Error：服务器内部错误，无法完成请求。
  - **502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。
  - 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。
  - 504 Gateway Timeout：充当网关或代理的服务器，未及时从远端服务器获取请求。



### 24. HTTP长连接和短连接

+ 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

+ 从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头有加入这行代码：`Connection:keep-alive`。
+ ==HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。==长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况（数据库的连接）。短连接（WEB 网站的 http 服务）。



### 25. HTTP 与 TCP/IP 的关系

HTTP 的长连接和短连接本质上是 TCP 长连接和短连接。HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠的传递数据包。



### 26. HTTP 1.0 vs HTTP 1.1

1. **连接方式**：HTTP 1.0 为短连接，HTTP 1.1 支持长连接。
2. **状态响应码**：HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
3. **缓存处理**：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match 等更多可供选择的缓存头来控制缓存策略。
4. **带宽优化及网络连接的使用**：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
5. **Host头处理**：HTTP/1.1在请求头中加入了`Host`字段。

```http
GET /home.html HTTP/1.1
Host: example1.org
```



HTTP 2.0

P190



### 27. HTTPS协议

HTTPS 协议（Hyper Text Transfer Protocol **Secure**），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并`额外使用 SSL/TLS 协议用作加密和安全认证`。默认端口号是 443。

HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。



### 28. SSL/TLS 的工作原理

##### a. 非对称加密

非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。

#####  b. 对称加密

通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。

（使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。）

网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，`使用非对称加密，对对称加密的密钥进行加密`，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。

##### c. 数字证书

证书颁发机构（CA，Certificate Authority） 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的**电子签名**。

当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。

##### d. 数字签名

CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。

现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。

客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。



### 29. HTTPS vs HTTP

- **端口号** ：HTTP 默认是 80，HTTPS 默认是 443。
- **URL 前缀** ：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
- **安全性和资源消耗** ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。



### 30. DNS

DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。

+ 通过主机名，最终得到该主机名对应的IP地址的过程叫做`域名解析`。
+ 将主机域名转换为IP地址，属于应用层协议，使用UDP传输。



### 31. DNS工作原理

1. 当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，有解析结束；`浏览器缓存`
2. 若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束；`系统缓存 -> 路由器缓存`
3. 若无命中，则请求本地域名服务器（LDNS）解析；`本地域名服务器缓存`
4. 若LDNS没有命中就直接跳到根域名服务器请求解析，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；`根域名服务器缓存 -> 顶级域名服务器缓存`
5. 顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉LDNS服务器；`主域名服务器缓存`
6. 主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；把IP地址告诉LDNS服务器；
7. LDNS缓存这个域名和对应的IP，把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。

> TTL(Time-To-Live)，简单的说它表示一条域名解析记录在DNS服务器上缓存时间。

[域名服务器](https://blog.csdn.net/qq_36610334/article/details/120064572)



### 32. 递归 & 迭代查询

+ 主机向本地域名服务器的查询一般都是采用递归查询

如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么`本地域名服务器`就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文（即`替主机继续查询`），而不是让主机自己进行下一步查询。

+ 本地域名服务器向根域名服务器的查询的迭代查询

当`根域名服务器`收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器，下一步应当向哪一个域名服务器进行查询，然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的`顶级域名服务器`的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。

顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个`权限域名服务器`进行查询。

> 递归查询，返回的结果只有两种：查询成功或查询失败。
>
> 迭代查询，又称作重指引，返回的是最佳的查询点或者主机地址。



### 33. DNS负载均衡

DNS服务器中`为同一个主机名配置多个IP地址`，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址`按顺序返回不同的解析结果`，将客户端的访问`引导到不同的机器上去`，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。



### 34. ARP

ARP（Address Resolution Protocol，地址解析协议）**用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址**。`网络层协议`

##### a. ARP广播

ARP协议将请求包**以广播的形式**发送，交换机或WiFi设备（无线路由器）收到广播包时，会将此数据发给同一局域网的其他所有主机。

目的主机在收到请求之后，就可以将源主机的IP和MAC映射信息存储在本地的`ARP缓存表`，返回**ARP单播回应**包。其他主机收到请求，发现目的地址不是自己则丢弃。

> 大部分广播包的共同特征：**二层封装时目的MAC是全f（ffff.ffff.ffff）或三层封装时目的IP是全1（255.255.255.255）**

##### b. ARP代理

对于**不在同一物理网络但属于相同网段的主机**，可以在其之间的路由器上部署ARP代理功能，以实现这些主机之间的通信。部署ARP代理功能后，路由器收到ARP请求报文且发现其目的地址不是自己，则使用`路由器自己的MAC地址`以及`目的主机的IP地址`向源主机回复ARP响应报文，即交换机代替目的主机回复ARP响应报文。



### 35. ICMP

ICMP（Internet Control Message Protocol，网际控制报文协议）主要用于在IP主机和路由器之间传递控制消息，用于报告**主机是否可达**、**路由是否可用**等。`网络层协议`

##### a. Ping程序

Ping程序是最常见的用于`检测IPv4和IPv6网络设备是否可达的调试手段`，它使用`ICMP的echo信息`来确定：

- 远程设备是否可达；
- 与远程主机通信的来回旅程（round-trip）的延迟；
- 报文包的丢失情况。

##### b. Traceroute程序

Tracert程序主要用于`查看数据包从源端到目的端的路径信息`，从而`检查网络连接是否可用`。当网络出现故障时，用户可以使用该命令定位故障点。

Tracert利用`ICMP超时信息`和`目的不可达信息`来确定从一个主机到网络上其他主机的路由，并显示IP网络中每一跳的延迟。



### 36. socket编程

##### a. 网络中如何唯一标识一个进程？

TCP/IP协议族已经帮我们解决了这个问题，网络层的“**ip地址**”可以唯一标识网络中的主机，而传输层的“**协议+端口**”可以唯一标识主机中的应用程序（进程）。这样利用`三元组（ip地址，协议，端口）`就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。



##### b. socket()

==socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。==

```c++
int socket(int domain, int type, int protocol);
```

- domain：即协议域，又称为协议族（family）。常用的协议族有，`AF_INET`、`AF_INET6`、`AF_LOCAL`（或称`AF_UNIX`，Unix域socket）、`AF_ROUTE`等等。**协议族决定了socket的地址类型**，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
- type：指定socket类型。常用的socket类型有，`SOCK_STREAM`、`SOCK_DGRAM`、`SOCK_RAW`、`SOCK_PACKET`、`SOCK_SEQPACKET`等等。
- protocol：指定协议。常用的协议有，`IPPROTO_TCP`、`IPPROTO_UDP`、`IPPROTO_SCTP`、`IPPROTO_TIPC`等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。当protocol为0时，会自动选择type类型对应的默认协议。



##### c. bind()

==bind()把一个地址族中的特定地址赋给socket。例如对应`AF_INET`、`AF_INET6`就是把一个ipv4或ipv6地址和端口号组合赋给socket。==

```c++
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- sockfd：即socket描述字。bind()函数就是将给这个描述字绑定一个名字。
- addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。

- addrlen：对应的是地址的长度。

**服务器端在listen()之前会调用bind()，绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，而客户端就不会调用，而是在connect()时由系统自动分配一个端口号和自身的ip地址组合。**



##### d. listen() & connect()

==服务器在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。==

```c++
int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

listen函数

+ sockfd：要监听的socket描述字。

+ backlog：相应socket可以排队的最大连接个数。

connect函数

+ sockfd：客户端的socket描述字。
+ addr：服务器的socket地址。
+ addrlen：服务器的socket地址的长度。



##### e. accept()

```c++
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

+ sockfd：服务器的socket描述字。
+ addr：指向struct sockaddr *的指针，用于返回客户端的协议地址。
+ addrlen：协议地址的长度。

如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字（`已连接的socket描述字`），代表与返回客户的TCP连接。



##### f. read() & write()

##### g. close()







客户端/服务端













11. IO多路复用select，poll，epoll区别/优劣，epoll的两种模式
    1. select为啥有10241的限制，32*i32
    2. epoll线程安全
    3. reactor vs proactor
    4. https://blog.csdn.net/adminpd/article/details/124553590

[Java Guide](https://javaguide.cn/cs-basics/network/other-network-questions.html#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-url-%E5%9C%B0%E5%9D%80-%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B-%E9%9D%A2%E8%AF%95%E5%B8%B8%E5%AE%A2)









































# 操作系统

### 进程与线程

+ 进程是资源分配的基本单位，线程是资源调度的基本单位





























# C++

### 1. auto、auto& 和 const auto&

**auto :** `for(auto x:range)`会拷贝一份range元素，对x的操作不会修改range中的元素

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    vector<int> range={1,2,3,4,5};
    for(auto x:range){
        x=x+1;
    }
    return 0;
}
//range(1,2,3,4,5)
```

**auto& :** `for(auto& x:range)`修改了原容器中元素的值，&代表引用，不会拷贝

**auto&& :** `for(auto&& x:range)`也可以修改元素的值（一般用这种方法），不会拷贝

**const auto& :** `for(const auto& x:range)`只能读取range中的元素，不可修改

**const auto :** `for(const auto x:range)`只拷贝元素，不可修改拷贝出来的值

**Tips：auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低**



### 2. const

##### a. 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；**（没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰）**
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

==记忆：被 const 修饰（在 const 后面）的值不可改变，p2、p3==

##### b. 使用

```c++
// 类
class A{
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化
public:
    // 构造函数
    A() : a(0) { };
    A(int x) : a(x) { };        // 初始化列表

    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function(){
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char* Var);         // 参数指针所指内容为常量
void function3(char* const Var);         // 参数指针为常量
void function4(const int& Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```



### 3. 宏定义 #define 和 const 常量

|    宏定义 #define    |   const 常量   |
| :------------------: | :------------: |
|    相当于字符替换    |    常量声明    |
|     预处理器处理     |   编译器处理   |
|    无类型安全检查    | 有类型安全检查 |
|      不分配内存      |   要分配内存   |
|     存储在代码段     |  存储在数据段  |
| 可通过 `#undef` 取消 |    不可取消    |

**预处理器：真正的编译开始之前由编译器调用的独立程序**

**类型安全：访问可以被授权访问的内存位置**



### 4. static

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，**在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，**表明函数的作用范围，仅在定义该函数的文件内才能使用**。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，**修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员**。
4. 修饰成员函数，**修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员**。



### 5. this指针

1. `this` 指针是一个隐含于每一个**非静态成员函数**中的特殊指针，它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。
6. 在以下场景中，经常需要显式引用`this`指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 `list`。



### 6. inline 内联函数

##### a. 特征

- 相当于把内联函数里面的内容写在调用内联函数处；
- **相当于不用执行进入函数的步骤，直接执行函数体**；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中**定义**的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

##### b. 使用

```c++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

##### c. 优点

1. 内联函数同宏函数一样将**在被调用处进行代码展开**，**省去了参数压栈、栈帧开辟与回收，结果返回等**，从而提高程序运行速度；
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会；
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能；
4. 内联函数在运行时可调试，而宏定义不可以。

##### d. 缺点

1. **代码膨胀**。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. **inline 函数无法随着函数库升级而升级**。inline函数的改变需要重新编译，不像 non-inline 可以直接链接；
3. 是否内联，**程序员不可控**。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

> **虚函数（virtual）可以是内联函数（inline）吗？**
>
> - 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联
> - 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联
> - `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```



### 7. volatile

```
volatile int i = 10; 
```

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以**使用 volatile 告诉编译器不应对这样的对象进行优化**。
- volatile 关键字声明的变量，**每次访问时都必须从内存中取出值**（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile



### 8. assert()

断言，是宏，而非函数。

assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，**其作用是如果它的条件返回错误，则终止程序执行**。

可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。

```c++
#define NDEBUG          // 加上这行，则 assert 不可用
#include <assert.h>

assert( p != NULL );    // assert 不可用
```



### 9. sizeof()

- sizeof 对数组，得到整个数组所占空间大小
- sizeof 对指针，得到指针本身所占空间大小



### 10. #pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐

```c++
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1; 			//(1)+3
    double m4;   	//(8)
    int m3;				//(4)
};

#pragma pack(pop)   // 恢复对齐状态
```



### 11. 结构体内存对齐

- 结构体内成员按照声明顺序存储

- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）

- 结构体的内存大小为**有效对齐值**的整数倍，不足的需要补齐

- 当结构体嵌套了结构体时，作为数据成员的结构体的自身长度作为外部结构体的最大成员的内存大小，比如结构体a嵌套结构体b，b中有char、int、double等，则b的自身长度为8

  ```c++
  struct TestStructA{
      char d;//16
      int e;//20-23
      short f;//24-25
      double g;//32-39
  }structA;
  
  struct TestStructB{
      char a;//0
      int b;//4-7
      short c;//8-9
      struct TestStructA sturctA_1;
  }structB;
  
  int main(){
      cout<<sizeof(structB)<<endl;//40 按8字节对齐
      return 0;
  }
  /**
  *   0   1   2   3   4   5   6   7
  *  |a|        |         b         |
  *   8   9   10  11  12  13  14  15
  *  |  c   |
  *   16  17  18  19  20  21  22  23   
  *  | d |
  */
  ```

  

  **==目的==：** 
  
  **a. 程序的执行效率提高** （一般情况，CPU以字节大小（32位处理器4个字节）访问数据，如果数据没有内存对齐，CPU访问这些数据时，可能需要执行多次的读取操作，为了让CPU能一次获取到数据，从而提升性能）
  
  **b. 访问范围提高** 
  
  **c. 原子性的保障** （CPU 每次访问数据的宽度是一个字，要么完整地被执行,要么完全不执行）



### 12.位域

类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。

```c++
include <stdio.h>

int main(){
  
	//1.位域允许我们使用内存最小单位BIT位来存储数据,某些情况下可以为我们节省内存
	//2.位域是以数据类型来区分区域的,几种数据类型就表示有几个位域段( 未指定占用位,除外 )
	//3.同种位域类使用BIT位超过该位域数据类型大小自动完后继续占用该位域数据类型大小
	//4.未用完的BIT位还是要占用内存空间的即不存在只使用int类型的其中4位,后面28位还是要占用空间的
	//5.无法对位域成员变量取地址操作,因为我们无法取得某个BIT位的地址
	//6.位域一般使用unsigned数据类型
	//7.未指定占用位默认占用所有位数
	//8.位域遵循结构体对齐原则

struct Test
{
	//
	//第一个位域区域为int可以用空间位数为sizeof( int ) * 8 = 32位
	//刚好用完32位( 如果超过32位则自动往后移动32位即整个占用64位内存8字节大小 )
	unsigned int a:4;	//占用4位( 范围 0 - 2^4 -1 )
	unsigned int b:5;	//占用5位( 范围 0 - 2^5 -1 )
	unsigned int c:3;	//占用3位( 范围 0 - 2^3 -1 )
	unsigned int d:16;	//占用16位( 范围 0 - 2^16 -1 )
	//
	
	//
	//第二个位域区域为char可以用空间位数为sizeof( char ) * 8 = 8位
	//使用位数12位超过8位则自动往后移动8位即整个占用16位内存2字节大小 )
	unsigned char e:5;	//占用5位( 范围 0 - 2^5 -1 )
	unsigned char f:7;	//占用7位( 范围 0 - 2^7 -1 )
	//
 
	//
	//第三个位域区域为short可以用空间位数为sizeof( short ) * 8 = 16位
	//刚好用完16位
	unsigned short g:10;
	unsigned short h:6;
 
	//
	//第四个位域区域为char可以用空间位数为sizeof( char ) * 8 = 8位
	//未指定占用位数默认占用所有位数
	unsigned char i;
};

//整个结构体位域占用4 + 2 + 2 + 1 = 9个字节
//因为存在字节对齐则实际占用12个字节
Test t = {};
 
//不能这样使用
//unsigned int *p = &t.a;
 
const int size = sizeof( Test );
printf( "位域大小:%d字节\n", size );
return 0;
}
```


### 13. extern "C"

1. extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。也就是说，在一个文件中定义了变量和函数，在其他文件中要使用它们，可以有两种方式：使用头文件，然后声明它们，然后其他文件去包含头文件；在其他文件中直接extern。
2. `extern "C"` 的作用是让 C++ 编译器将 `extern "C"` 声明的代码当作 C 语言代码处理，被 `extern "C"` 修饰的变量和函数是按照 C 语言方式编译和链接的，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。

```c++
#ifdef __cplusplus		//如果是被c++文件引用的话，extern "C"就会生效，否则extern "C"不生效
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```



### 14. struct 和 typedef struct

1. 如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索**全局标识符表**，`Student` 未找到，则搜索**类标识符**。即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：

```c++
// cpp
struct Student { 
    int age; 
};

void f( Student me );       // 正确，"struct" 关键字可省略
```

2. 若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：

```c++
typedef struct Student { 
    int age; 
} S;

void Student() {}           // 正确，定义后 "Student" 只代表此函数

//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名

int main() {
    Student(); 
    struct Student me;      // 或者 "S me";
    return 0;
}
```



### 15. struct 和 class

1. 总的来说，struct 更适合看成是一个**数据结构的实现体**，class 更适合看成是一个**对象的实现体**。

2. 最本质的一个区别就是**默认的访问控制**

   + 默认的继承访问权限。struct 是 public 的，class 是 private 的。

   + struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。



### 16. union 联合

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

```c++
#include<iostream>

union UnionTest {
    UnionTest() : i(10) {};
    int i;
    double d;
};

static union {	// 全局匿名联合
    int i;
    double d;
};

int main() {
    UnionTest u;

    union {			// 局部匿名联合
        int i;
        double d;
    };

    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10

    ::i = 20;
    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20

    i = 30;
    std::cout << i << std::endl;    // 输出局部匿名联合的 30

    return 0;
}
```



### 17. explicit（显式）关键字

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

```c++
struct A
{
	A(int) { }
	operator bool() const { return true; }
};

struct B
{
	explicit B(int) {}
	explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
	A a1(1);		// OK：直接初始化
	A a2 = 1;		// OK：复制初始化
	A a3{ 1 };		// OK：直接列表初始化
	A a4 = { 1 };		// OK：复制列表初始化
	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
	doA(1);			// OK：允许从 int 到 A 的隐式转换
	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a6(a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

	B b1(1);		// OK：直接初始化
	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
	B b3{ 1 };		// OK：直接列表初始化
	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

	return 0;
}
```



### 18. friend 友元类和友元函数

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制



### 19. using

- using 声明

```c++
using std::cin;
```

- using 指示

```c++
using namespace std;
```

- 构造函数的 using 声明

在 C++11 中，派生类能够重用其**直接基类**定义的构造函数，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数

```c++
class Derived : Base {
public:
    using Base::Base;
    /* ... */
};
```



### 20. :: 范围解析运算符

1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间；
2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的；
3. 命名空间作用域符（`namespace::name`）：用于表示指定类型的作用域范围是具体某个命名空间的。

```c++
int count = 11;         // 全局（::）的 count

class A {
public:
	static int count;   // 类 A 的 count（A::count）
};
int A::count = 21;

void fun()
{
	int count = 31;     // 初始化局部的 count 为 31
	count = 32;         // 设置局部的 count 的值为 32
}

int main() {
	::count = 12;       // 测试 1：设置全局的 count 的值为 12
	A::count = 22;      // 测试 2：设置类 A 的 count 为 22
	fun();		        // 测试 3
	return 0;
}
```



### 21. enum 枚举类型

##### a. 限定作用域的枚举类型

```c++
enum class color {red, yellow, green};
color a = green;			// 错误，限定作用域的枚举成员在类型外不可访问
color a = color::green;		
```

##### b. 不限定作用域的枚举类型

```c++
enum color {red, yellow, green};
color a = green;			// 不限定作用域的枚举类型外可以使用枚举成员

enum {floatPrec = 6, doublePrec = 10};
```



### 22. decltype

decltype 关键字用于**选择并返回操作数的数据类型**。



### 23. 引用

##### a. 左值引用

非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定到非常量左值、常量左值、非常量右值、常量右值等所有的值类型。

```c++
int a=10;              //非常量左值（有确定存储地址，也有变量名）
const int a1=10;       //常量左值（有确定存储地址，也有变量名）
const int a2=20;       //常量左值（有确定存储地址，也有变量名）
 
//非常量左值引用
int &b1=a;         //正确，a是一个非常量左值，可以被非常量左值引用绑定
int &b2=a1;        //错误,a1是一个常量左值，不可以被非常量左值引用绑定
int &b3=10;        //错误，10是一个非常量右值，不可以被非常量左值引用绑定
int &b4=a1+a2;  //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定

//常量左值引用
const int &c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定
const int &c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定
const int &c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定
const int &c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定
```

##### b. 右值引用

非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。

主要目的：

- **消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。**
- 能够更简洁明确地定义泛型函数。

```c++
int a=10;             //非常量左值（有确定存储地址，也有变量名）
const int a1=20;      //常量左值（有确定存储地址，也有变量名）
const int a2=20;      //常量左值（有确定存储地址，也有变量名）

//非常量右值引用
int &&b1=a;         //错误，a是一个非常量左值，不可以被非常量右值引用绑定
int &&b2=a1;        //错误,a1是一个常量左值，不可以被非常量右值引用绑定
int &&b3=10;        //正确，10是一个非常量右值，可以被非常量右值引用绑定
int &&b4=a1+a2; //错误,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定

//常量右值引用
const int &&c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定
const int &&c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定
const int &&c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定
const int &&c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定
```



### 24. 宏

宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。



### 25. 成员初始化列表

- 更高效：少了一次调用默认构造函数的过程。
- 有些场合必须要用初始化列表：
  1. **常量成员**，因为常量只能初始化不能赋值，所以必须放在初始化列表里面；
  2. **引用类型**，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面；
  3. **没有默认构造函数的类类型**，因为使用初始化列表可以不必调用默认构造函数来初始化。



### 26. 面向对象

面向对象三大特征 —— 封装、继承、多态

##### 1. 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- `public` 成员：可以被任意实体访问
- `protected` 成员：只允许被子类及本类的成员函数访问
- `private` 成员：只允许被本类的成员函数、友元类或友元函数访问

##### 2. 继承

- 基类（父类）——> 派生类（子类）

##### 3. 多态

- 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。
- 多态是以封装和继承为基础的。
- C++ 多态分类及实现：
  1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
  2. 子类型多态（Subtype Polymorphism，运行期）：虚函数
  3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
  4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

**静态多态（编译期/早绑定）**

- 函数重载

```c++
class A
{
public:
    void do(int a);
    void do(int a, int b);
};
```

**动态多态（运行期期/晚绑定）**

- 虚函数：用 virtual 修饰成员函数，使其成为虚函数，当基类指针指向子类对象时候，虚函数能实现运行时多态
- 动态绑定：当使用**基类的引用或指针**调用一个虚函数时将发生动态绑定

```c++
class Shape                     // 形状类
{
public:
    virtual double calcArea()
    {
        ...
    }
    virtual ~Shape();
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
class Rect : public Shape       // 矩形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    Shape * shape2 = new Rect(5.0, 6.0);
    shape1->calcArea();         // 调用圆形类里面的方法
    shape2->calcArea();         // 调用矩形类里面的方法
    delete shape1;
    shape1 = nullptr;
    delete shape2;
    shape2 = nullptr;
    return 0;
}
```

- **可以将派生类的对象赋值给基类的指针或引用，反之不可**
- 普通函数（非类成员函数）不能是虚函数
- 静态函数（static）不能是虚函数
- **构造函数不能是虚函数**（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
- 内联函数不能是表现多态性时的虚函数



### 27. 虚析构函数

当基类的指针指向派生类对象，并用**基类的指针删除派生类对象**，需要把基类的析构函数设置成虚析构，防止内存泄露。

+ 基类析构函数不定义为虚析构，当我们用基类指针指向子类对象的时候，只会调用基类析构函数
+ 当基类设置为虚析构，子类的析构函数会被调用，且子类的析构函数不需要设置为虚析构，孙子类的析构函数仍然会调用

```c++
class Shape{
public:
    Shape();                    // 构造函数不能是虚函数
    virtual double calcArea();
    virtual ~Shape();           // 虚析构函数
};
class Circle : public Shape     // 圆形类
{
public:
    virtual double calcArea();
    ...
};
int main()
{
    Shape * shape1 = new Circle(4.0);
    shape1->calcArea();    
    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
    shape1 = nullptr;
    return 0；
}
```



### 28. 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加"=0"。

```c++
virtual int A() = 0;
```



### 29. 虚函数、纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- **带纯虚函数的类叫抽象类**，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- **虚基类**是虚继承中的基类，具体见下文虚继承。

[CSDN . C++ 中的虚函数、纯虚函数区别和联系](https://blog.csdn.net/u012260238/article/details/53610462)



### 30. 虚函数指针、虚函数表

- 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。
- 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](https://github.com/huihut/interview#目标文件存储结构)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。



### 31. 虚继承

+ 虚继承用于解决`多重继承`条件下的菱形继承问题（浪费存储空间、存在二义性）。

+ 虚继承的底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（额外的空间，不占用实例对象的存储空间）。需要强调的是，**虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已**，当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

+ 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），**虚表中记录了虚基类与本类的偏移地址**；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

[详细讲解虚继承](https://blog.csdn.net/galaxyrt/article/details/118118831)

[C++虚继承中的虚基类表](https://blog.csdn.net/code_peak/article/details/118887325)



### 32. 虚继承、虚函数

- 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
- 不同之处：
  - 虚继承
    - 虚基类依旧存在继承类中，只占用存储空间
    - 虚基类表存储的时虚基类相对当前实例对象的偏移
  - 虚函数
    - 虚函数不占用存储空间
    - 虚函数表存储的是虚函数地址



### 33. 模板类、成员模板、虚函数

- 模板类中可以使用虚函数
- 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数



### 34. 抽象类、接口类、聚合类

- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
  - 所有成员都是 public
  - 没有定义任何构造函数
  - 没有类内初始化
  - 没有基类，也没有 virtual 函数

[C++ 语言聚合类](https://blog.csdn.net/chengyq116/article/details/119766363)



### 35. 内存分配和管理

#### a. malloc、calloc、realloc、alloca

1. malloc：申请指**定字节数**的内存。申请到的内存中的初始值不确定。
2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。
3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

#### b. malloc、free

用于分配、释放内存

```c++
char *str = (char*) malloc(100);// 申请内存
assert(str != nullptr);					// 确认是否申请成功
```

释放内存后指针置空

```c++
free(p); 
p = nullptr;
```

#### c. new、delete

1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
2. delete / delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
3. **new 在申请内存时会自动计算所需字节数**，而 malloc 则需我们自己输入申请内存空间的字节数。

```c++
int main()
{
    T* t = new T();     // 先内存分配 ，再构造函数
    delete t;           // 先析构函数，再内存释放
    return 0;
}
```

#### d. 定位 new

定位 new（placement new）允许我们向 new 传递额外的地址参数，从而**在预先指定的内存区域创建对象**。

```c++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
```

- `place_address` 是个指针
- `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表



### 36. delete this 合法吗？

合法，但：

1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数
3. 必须保证成员函数的 `delete this `后面没有调用 this 了
4. 必须保证 `delete this` 后没有人使用了



### 37.如何定义一个只能在堆上（栈上）生成对象的类？

##### a. 只能在堆上

方法：将析构函数设置为私有

原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

##### b. 只能在栈上

方法：将 new 和 delete 重载为私有

原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。



### 38. 智能指针

#### C++ 标准库（STL）中

头文件：`#include <memory>`

#### C++ 98

```c++
std::auto_ptr<std::string> ps (new std::string(str))；
```

#### C++ 11

1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被 C++11 弃用）

- Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
- Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

##### shared_ptr

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

- 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

##### weak_ptr

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

- 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

##### unique_ptr

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

- unique_ptr 用于取代 auto_ptr

##### auto_ptr

被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。

##### auto_ptr 与 unique_ptr 比较

- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；
- auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；















