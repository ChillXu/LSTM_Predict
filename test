


**协程：**

`协程是用户视角的一种抽象，操作系统并没有协程的概念`。

协程运行在线程之上，协程的主要思想是在用户态实现调度算法，`用少量线程完成大量任务的调度`。

协程需要解决线程遇到的几个问题：

1. 内存占用要小，且创建开销要小
   + 用户态的协程，可以设计的很小，可以达到 KB 级别，是线程的千分之一
   + 线程栈空间通常是MB级别， 协程栈空间最小KB级别

2. 减少上下文切换的开销
   + 让可执行的线程尽量少，这样切换次数必然会少
   + 让线程尽可能的处于运行状态，而不是阻塞让出时间片
     + 多个协程绑定一个或者多个线程上
     + 当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上（分时复用）
     + 即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上

3. 降低开发难度
   + goroutine是golang中对协程的实现，goroutine底层实现了少量线程干多事，减少切换时间等
   + 程序员可以轻松创建协程，无需去关注底层性能优化的细节





### 43. 线程安全

##### 1. 概念

**线程安全：**

+ `多个线程并发同一段代码时，不会出现不同的结果`。常见对全局变量或者静态变量进行操作，并且没有锁保护的情况下，会出现该问题。

**重入：**

- 同一个函数被不同的执行流调用，当前一个流程还没有执行完，就有其他的执行流再次进入，我们称之为重入。一个函数在重入的情况下，运行结果不会出现任何不同或者任何问题，则该函数被称为`可重入函数`，否则，是不可重入函数。



##### 2. 常见的线程不安全的情况

- 不保护共享变量的函数
- 函数状态随着被调用，状态发生变化的函数

- 返回指向静态变量指针的函数

- 调用`线程不安全函数`的函数



##### 3. 常见的线程安全的情况

- 每个线程对全局变量或者静态变量只有读取的权限，而没有写入的权限，一般来说这些线程是安全的

- 类或者接口对于线程来说都是原子操作

- 多个线程之间的切换不会导致该接口的执行结果存在二义性



##### 4. 常见的不可重入的情况

- 调用了malloc/free函数，因为malloc函数是用全局链表来管理堆的
- 调用了标准I/O库函数，标准I/O库的很多实现都以不可重入的方式使用全局数据结构
- 可重入函数体内使用了静态的数据结构



##### 5. 常见的可重入的情况

- 不使用全局变量或静态变量
- 不使用用malloc或者new开辟出的空间
- 不调用不可重入函数
- 不返回静态或全局数据，所有数据都有函数的调用者提供
- 使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据



##### 6. 可重入与线程安全联系

- 函数是可重入的，那就是线程安全的
- 函数是不可重入的，那就不能由多个线程使用，有可能引发线程安全问题
- 如果一个`函数中有全局变量`，那么这个函数既不是线程安全也不是可重入的



##### 7. 可重入与线程安全区别

- 可重入函数是线程安全函数的一种
- 线程安全不一定是可重入的，而可重入函数则一定是线程安全的
- `如果将对临界资源的访问加上锁，则这个函数是线程安全的`，但如果这个重入函数若锁还未释放则会产生死锁，因此是不可重入的



### 

[Linux 基础IO](https://blog.csdn.net/qq_54851255/article/details/124908170)

inode，软连接、硬连接，文件描述符

https://blog.csdn.net/weixin_57023347/article/details/119883952
